<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数据结构与算法-学习笔记(持续更新中...)</title>
    <url>/2022/08/17/AlgorithmNote/</url>
    <content><![CDATA[<h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><h2 id="关于如何使用Clion运行多个main函数？"><a href="#关于如何使用Clion运行多个main函数？" class="headerlink" title="关于如何使用Clion运行多个main函数？"></a>关于如何使用Clion运行多个main函数？</h2><p>用以下代码取代添加可执行文件代码：<code>add_executable(xxx xxx.cpp/h)</code>,对于每一个.cpp文件都会生成对应的.exe文件。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">#递归遍历所有的cpp文件</span><br><span class="line"><span class="built_in">file</span> (GLOB_RECURSE files *.cpp)</span><br><span class="line"></span><br><span class="line">#将所有的cpp文件单独生成可执行文件</span><br><span class="line">foreach (file $&#123;files&#125;)</span><br><span class="line"><span class="built_in">string</span>(REGEX REPLACE <span class="string">&quot;.+/(.+)\\..*&quot;</span> <span class="string">&quot;\\1&quot;</span> exe $&#123;file&#125;)</span><br><span class="line"><span class="built_in">add_executable</span> ($&#123;exe&#125; $&#123;file&#125;)</span><br><span class="line"><span class="built_in">message</span> (\ \ \ \ --\ src/$&#123;exe&#125;.cpp\ will\ be\ compiled\ to\ bin/$&#123;exe&#125;)</span><br><span class="line"><span class="built_in">endforeach</span> ()</span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<p>1.每次添加新文件后需要重新加载CMake项目。</p>
<p>2.这样修改适合使用Clion用于c++刷题。</p>
<h2 id="一-认识复杂度和简单排序算法"><a href="#一-认识复杂度和简单排序算法" class="headerlink" title="一.认识复杂度和简单排序算法"></a>一.认识复杂度和简单排序算法</h2><h3 id="1-时间复杂度"><a href="#1-时间复杂度" class="headerlink" title="1.时间复杂度"></a>1.时间复杂度</h3><h4 id="1-1常数操作定义"><a href="#1-1常数操作定义" class="headerlink" title="1.1常数操作定义"></a>1.1常数操作定义</h4><p>一个操作如果和样本的数据量没有关系，每次都是固定时间内完成的操作，叫做常数操作。</p>
<h4 id="1-2求解时间复杂度"><a href="#1-2求解时间复杂度" class="headerlink" title="1.2求解时间复杂度"></a>1.2求解时间复杂度</h4><p>在算法流程中找出发生了多少常数操作，进而写出常数操作数量的表达式，取其最高项次数f(n),则时间复杂度为O(f(n))。</p>
<h4 id="1-3评价一个算法流程的好坏"><a href="#1-3评价一个算法流程的好坏" class="headerlink" title="1.3评价一个算法流程的好坏"></a>1.3评价一个算法流程的好坏</h4><p>先看时间复杂度，随后分析不同数据样本下的实际运行时间。</p>
<p>如下代码经多次运行测试，process2大部分情况下要比process1用时短。</p>
<p>原因：</p>
<p>1.加法-基本运算：异或操作。</p>
<p>2.减法-补码加运算：实际上加法也是补码加运算，只是在数据前用0表示正，1表示负。</p>
<p>3.乘法-移位相加。</p>
<p>4.除法-移位相减。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> @author : Song Jiaqi </span></span><br><span class="line"><span class="comment"> @date : 2022-08-10 12:24  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">process1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> N = <span class="number">1000</span>;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            a = <span class="number">2</span> + <span class="number">6</span>;</span><br><span class="line">            a = <span class="number">6</span> * <span class="number">9</span>;</span><br><span class="line">            a = <span class="number">8</span> * <span class="number">4</span>;</span><br><span class="line">            a = <span class="number">90</span> / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">process2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> N = <span class="number">1000</span>;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="comment">//位运算</span></span><br><span class="line">            a = <span class="number">2</span> | <span class="number">6</span>;</span><br><span class="line">            a = <span class="number">6</span> &amp; <span class="number">9</span>;</span><br><span class="line">            a = <span class="number">8</span> &amp; <span class="number">4</span>;</span><br><span class="line">            a = <span class="number">90</span> ^ <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> t1 = chrono::steady_clock::<span class="built_in">now</span>();<span class="comment">//获取开始时间</span></span><br><span class="line">    test::<span class="built_in">process1</span>();</span><br><span class="line">    <span class="keyword">auto</span> t2 = chrono::steady_clock::<span class="built_in">now</span>();<span class="comment">//获取结束时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> t3 = chrono::steady_clock::<span class="built_in">now</span>();<span class="comment">//获取开始时间</span></span><br><span class="line">    test::<span class="built_in">process2</span>();</span><br><span class="line">    <span class="keyword">auto</span> t4 = chrono::steady_clock::<span class="built_in">now</span>();<span class="comment">//获取结束时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    double rs = chrono::duration&lt;double&gt;(t2-t1).count();//s为单位</span></span><br><span class="line"><span class="comment">//    double rms = chrono::duration&lt;double,milli&gt;(t2 - t1).count();//ms为单位</span></span><br><span class="line">    <span class="type">double</span> rus1 = chrono::<span class="built_in">duration</span>&lt;<span class="type">double</span>, micro&gt;(t2 - t1).<span class="built_in">count</span>();<span class="comment">//us为单位</span></span><br><span class="line">    <span class="type">double</span> rus2 = chrono::<span class="built_in">duration</span>&lt;<span class="type">double</span>, micro&gt;(t4 - t3).<span class="built_in">count</span>();<span class="comment">//us为单位</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;process1: &quot;</span> &lt;&lt; rus1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;process2: &quot;</span> &lt;&lt; rus2 &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-选择排序和冒泡排序复杂度分析"><a href="#2-选择排序和冒泡排序复杂度分析" class="headerlink" title="2.选择排序和冒泡排序复杂度分析"></a>2.选择排序和冒泡排序复杂度分析</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> @author : Song Jiaqi </span></span><br><span class="line"><span class="comment"> @date : 2022-08-10 14:34  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//选择排序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Code01_selectionSort</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//1.每一次循环都能得出一个最大值或最小值，随后得到次大和次小值，以此类推</span></span><br><span class="line">    <span class="comment">//2.因为前面已经有序，最后一个不需要排序</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">selectionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">NULL</span> || length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一层循环确定循环的趟数(length-1)次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> minIndex = i;</span><br><span class="line">            <span class="comment">//第二层循环确定每一躺的最小值的下标</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; length; j++) &#123;</span><br><span class="line">                minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果minIndex发生改变就与i进行交换，否则自己与自己交换无意义</span></span><br><span class="line">            <span class="keyword">if</span> (minIndex != i) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(arr, i, minIndex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//方法一</span></span><br><span class="line"><span class="comment">//        int temp = arr[i];</span></span><br><span class="line"><span class="comment">//        arr[i] = arr[j];</span></span><br><span class="line"><span class="comment">//        arr[j] = temp;</span></span><br><span class="line">        <span class="comment">//方法二</span></span><br><span class="line">        arr[i] = arr[i] ^ arr[j];</span><br><span class="line">        arr[j] = arr[i] ^ arr[j];</span><br><span class="line">        arr[i] = arr[i] ^ arr[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Code01_bubbleSort</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//每躺循环都能找出一个最大值，同时循环范围总长度要减一</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">NULL</span> || length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> lastChangeIndex = <span class="number">0</span>;<span class="comment">//记录最后一次改变的下标</span></span><br><span class="line">        <span class="type">int</span> sortBorder = length - <span class="number">1</span>;<span class="comment">//记录无序数组的边界</span></span><br><span class="line">        <span class="comment">//第一层循环确定循环次数(length-1)次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> e = length - <span class="number">1</span>; e &gt; <span class="number">0</span>; e--) &#123;</span><br><span class="line">            <span class="type">bool</span> isSorted = <span class="literal">true</span>;<span class="comment">//定义该变量来判断是否有序，在有序情况下就不进行排序</span></span><br><span class="line">            <span class="comment">//第二层循环每相邻两个数做比较，并把较大数放到右边。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sortBorder; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                    isSorted = <span class="literal">false</span>;<span class="comment">//有元素交换说明无序</span></span><br><span class="line">                    Code01_selectionSort::<span class="built_in">swap</span>(arr, i, i + <span class="number">1</span>);</span><br><span class="line">                    lastChangeIndex = i + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sortBorder = lastChangeIndex;</span><br><span class="line">            <span class="comment">//一趟下来是否发生位置交换，如果没有交换直接跳出大循环</span></span><br><span class="line">            <span class="keyword">if</span> (isSorted) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环遍历数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == length - <span class="number">1</span>) &#123;</span><br><span class="line">            cout &lt;&lt; arr[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//    int a[] = &#123;1,3,2,6,5,8,10,9,5,2,6&#125;;</span></span><br><span class="line"><span class="comment">//    int a[] = &#123;1, 3, 6, 8, 10, 5, 2, 9&#125;;</span></span><br><span class="line"><span class="comment">//    int a[] = &#123;5, 8, 5, 2, 9&#125;;</span></span><br><span class="line">    <span class="type">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="type">int</span> length = <span class="built_in">sizeof</span>(a) / <span class="built_in">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">//    Code01_selectionSort::selectionSort(a, length);</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; &quot;选择排序后：&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//    show(a, length);</span></span><br><span class="line">    Code01_bubbleSort::<span class="built_in">bubbleSort</span>(a, length);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;冒泡排序后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">show</span>(a, length);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-1出现的问题"><a href="#2-1出现的问题" class="headerlink" title="2.1出现的问题"></a>2.1出现的问题</h4><p> **a.*<em>warning: ‘sizeof’ on array function parameter ‘arr’ will return size of ‘int</em>‘ [-Wsizeof-array-argument]</p>
<p>警告：数组函数参数“arr”上的“sizeof”将返回“int*”的大小[-Wsizeof-array-argument]</p>
<p>原因：C&#x2F;C++中如果一个函数接受一个数组作为参数，那么数组将会被退化为指针。</p>
<p>解决办法：在main函数中用<code>sizeof(array)/sizeof(array[0])</code>算好length，再将length传入函数中。</p>
<p>**b.**选择排序有误</p>
<p>原因：比较时使用的是arr[i]而不是arr[minIndex]，在minIndex发生多次变化时会出现排序错误，而i是始终不变的。以下面这个</p>
<p>数组为例，当i&#x3D;8,minIndex&#x3D;8，在遇到第一个比8小的5后minIndex会变为5.而i仍然是8，这就导致如果用的是i作为下标进行比较，</p>
<p>随后minIndex还会变为6，导致排序错误。</p>
<p>参考数组：<code>int a[] = &#123;1, 3, 6, 8, 10, 5, 2, 9&#125;;</code></p>
<p>修改前：<code>minIndex = arr[j] &lt; arr[i] ? j : minIndex;</code></p>
<p><img src="img.png"></p>
<p>修改后：<code>minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex;</code></p>
<p><img src="img_1.png"></p>
<h4 id="2-2总结"><a href="#2-2总结" class="headerlink" title="2.2总结"></a>2.2总结</h4><p>**a.**选择排序是不稳定的排序。</p>
<p>在一趟选择，如果一个元素比当前元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中两个5的相对前后顺序就被破坏了。</p>
<p>**b.**冒泡排序是稳定的排序。</p>
<p>如果相邻两个元素相等，是不会交换的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的相对前后顺序并没有改变。</p>
<p>**c.**选择排序和冒泡排序区别：</p>
<p>选择排序会在一趟中选择最大或最小值，然后将进行交换将其放到最右或最左边。</p>
<p>冒泡排序会在一趟中对相邻元素进行比较，一趟结束后最大值会到达最右边。</p>
<p>**d.**复杂度分析-时间复杂度O(n^2),额外空间复杂度O(1)—有限个变量。</p>
<p>选择排序：</p>
<p>0-n-1：最小的放第一个位置，比较n-1次</p>
<p>1-n-1：最小的放第二个位置，比较n-2次</p>
<p>……</p>
<p>冒泡排序：</p>
<p>第一趟比较n-1次</p>
<p>第二趟比较n-2次</p>
<p>第三趟比较n-3次</p>
<p>……</p>
<p>均成等差数列：<img src="img_2.png"></p>
<h4 id="2-3异或运算的理解"><a href="#2-3异或运算的理解" class="headerlink" title="2.3异或运算的理解"></a>2.3异或运算的理解</h4><h5 id="2-3-1关于异或"><a href="#2-3-1关于异或" class="headerlink" title="2.3.1关于异或"></a>2.3.1关于异或</h5><p>1.不相同为1，相同为0或无进位相加。<img src="img_3.png"></p>
<p>2.性质：</p>
<p>​	a.0^n&#x3D;n; n^n&#x3D;0;</p>
<p>​	b.满足交换和结合律。 </p>
<p>3.为什么通过异或可以交换a,b的值？</p>
<p><strong>前提：a，b在内存中为独立的内存区域，两者值可以相同，但两种指向的内存区域不能相同。</strong></p>
<p><img src="img_4.png"></p>
<p><strong>内存区域相同的后果：i和j位置不能相等，否则相当于同样的内存区域自己在和自己异或，会变为0。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">    cout&lt;&lt;arr[i]&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;arr[j]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    arr[i]=arr[i]^arr[j];</span><br><span class="line">    arr[j]=arr[i]^arr[j];</span><br><span class="line">    arr[i]=arr[i]^arr[j];</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;arr[i]&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;arr[j]&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="img_5.png"></p>
<h5 id="2-3-2题目：找到出现奇数次的数"><a href="#2-3-2题目：找到出现奇数次的数" class="headerlink" title="2.3.2题目：找到出现奇数次的数"></a>2.3.2题目：找到出现奇数次的数</h5><p>要求：时间O(n),空间O(1)</p>
<p>情况：</p>
<p>1.一种数出现奇数次，其他数出现偶数次</p>
<p><strong>异或运算与数的顺序无关，与其出现的次数的奇偶性有关，奇为1，偶为0。</strong></p>
<p>2.两种数出现奇数次，其他数出现偶数次</p>
<p><strong>a.这种情况下，从头到尾进行异或运算可以得到a^b，因为a!&#x3D;b，a^b!&#x3D;0。也就是说在某一位上a为1，b为0，或者是</strong></p>
<p><strong>b为1，a为0。</strong></p>
<p><strong>b.原码&amp;补码(~原码+1)&#x3D;一个数最右侧的1(rightOne)，而这个1出现的位置n就是我们要找的位置。</strong></p>
<p><strong>c.遍历数组先从头到尾进行与运算，此次对象为rightOne，而rigthOne除了位置n，其余位置均为0，也就是说其他数相与后结果必为0，</strong></p>
<p><strong>因此根据在n位置相与的结果为0和不为0，对数组中的数进行划分，而a和b就在这两组之一中。假设条件：相与后为0，每符合条件就</strong></p>
<p><strong>进行一次异或，偶数次的数会消掉，最终剩下a&#x2F;b。</strong></p>
<p><strong>d.用a^b即eor,和a&#x2F;b即onlyOne进行异或，就能得到a&#x2F;b。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> @author : Song Jiaqi </span></span><br><span class="line"><span class="comment"> @date : 2022-08-11 11:36  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1个数出现奇数次</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">num1</span><span class="params">(vector&lt;<span class="type">int</span>&gt; <span class="type">const</span> &amp;arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> eor = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> cur:arr) &#123;</span><br><span class="line">        eor ^= cur;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1个数出现奇数次：&quot;</span> &lt;&lt; eor &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2个数出现奇数次</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">num2</span><span class="params">(vector&lt;<span class="type">int</span>&gt; <span class="type">const</span> &amp;arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从头异或到尾得到eor=a^b</span></span><br><span class="line">    <span class="type">int</span> eor = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> cur:arr) &#123;</span><br><span class="line">        eor ^= cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//原码与补码相与得到一个数最右侧的1。</span></span><br><span class="line">    <span class="type">int</span> rightOne = eor &amp; (~eor + <span class="number">1</span>);<span class="comment">//~取反，取反+1得到补码。</span></span><br><span class="line">    <span class="type">int</span> onlyOne = <span class="number">0</span>;<span class="comment">//eor&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> cur:arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((cur &amp; rightOne) == <span class="number">0</span>) &#123;<span class="comment">//条件为==0或!=0</span></span><br><span class="line">            onlyOne ^= cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;2个数出现奇数次：&quot;</span> &lt;&lt; onlyOne &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (onlyOne ^ eor) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="built_in">num1</span>(arr);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr2 = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="built_in">num2</span>(arr2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-插入排序的讲解和复杂度分析"><a href="#3-插入排序的讲解和复杂度分析" class="headerlink" title="3.插入排序的讲解和复杂度分析"></a>3.插入排序的讲解和复杂度分析</h3><p>时间复杂度O(n^2),额外空间复杂度O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> @author : Song Jiaqi </span></span><br><span class="line"><span class="comment"> @date : 2022-08-17 09:40  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapIndex</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    arr[i] = arr[i] ^ arr[j];</span><br><span class="line">    arr[j] = arr[i] ^ arr[j];</span><br><span class="line">    arr[i] = arr[i] ^ arr[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">NULL</span> || length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//0-0已经有序，想让0-i有序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="comment">//j指向当前所在数的前一个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; arr[j + <span class="number">1</span>]; j--) &#123;</span><br><span class="line">            <span class="built_in">swapIndex</span>(arr, j, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showArr</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="type">int</span> l = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">    <span class="built_in">insertionSort</span>(arr, l);</span><br><span class="line">    <span class="built_in">showArr</span>(arr, l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-1对时间复杂度的补充说明"><a href="#3-1对时间复杂度的补充说明" class="headerlink" title="3.1对时间复杂度的补充说明"></a>3.1对时间复杂度的补充说明</h4><p>a.O();O代表最差时间复杂度，要考虑最坏情况。</p>
<p>b.eg:7654321</p>
<p>0-1 交换1个</p>
<p>0-2 交换2个</p>
<p>0-3 交换3个</p>
<p>……</p>
<p>成等差数列，因此时间复杂度为O(n^2)。</p>
<h3 id="4-二分法的详解与扩展"><a href="#4-二分法的详解与扩展" class="headerlink" title="4.二分法的详解与扩展"></a>4.二分法的详解与扩展</h3><h4 id="4-1在一个有序数组中找某个数是否存在？"><a href="#4-1在一个有序数组中找某个数是否存在？" class="headerlink" title="4.1在一个有序数组中找某个数是否存在？"></a>4.1在一个有序数组中找某个数是否存在？</h4><p>a.如果使用直接遍历，复杂度为O(n)。</p>
<p>b.采用二分法，如果有16个数，考虑最坏情况，可划分为8,4,2,1个，需要4次即log2 16，</p>
<p>复杂度为log2 N(一般将其写为logN)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> @author : Song Jiaqi</span></span><br><span class="line"><span class="comment"> @date : 2022-08-10 12:24</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find1</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i:arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == num) &#123;</span><br><span class="line">            cout &lt;&lt; num &lt;&lt; <span class="string">&quot;存在&quot;</span> &lt;&lt; endl;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; <span class="string">&quot;不存在&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二分查找</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find2</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> low = <span class="number">0</span>, high = arr.<span class="built_in">size</span>()<span class="number">-1</span>, mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == num) &#123;</span><br><span class="line">            cout &lt;&lt; num &lt;&lt; <span class="string">&quot;存在&quot;</span> &lt;&lt; endl;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; num) &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; <span class="string">&quot;不存在&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="comment">//    find1(arr, 88);</span></span><br><span class="line">    <span class="built_in">find2</span>(arr, <span class="number">11</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2在一个有序数组中找某个-gt-x3D-某个数最左侧的位置"><a href="#4-2在一个有序数组中找某个-gt-x3D-某个数最左侧的位置" class="headerlink" title="4.2在一个有序数组中找某个&gt;&#x3D;某个数最左侧的位置"></a>4.2在一个有序数组中找某个&gt;&#x3D;某个数最左侧的位置</h4><p>​	仍然可以使用二分查找法，只是相对于4.1来说循环结束条件会不同，4.1是找到数就退出，而4.2中满足的数有很多，需要找到最左侧哪一个，因此需要等待low不断递增或者high不断递减，直到low&gt;high。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> @author : Song Jiaqi </span></span><br><span class="line"><span class="comment"> @date : 2022-08-10 12:24  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> low = <span class="number">0</span>, high = arr.<span class="built_in">size</span>() - <span class="number">1</span>, mid = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> f1 = <span class="number">0</span>;<span class="comment">//记录符合要求的下标</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt;= num) &#123;</span><br><span class="line">            f1 = mid;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;找到&gt;=&quot;</span> &lt;&lt; num &lt;&lt; <span class="string">&quot;的下标为：&quot;</span> &lt;&lt; f1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//    vector&lt;int&gt; arr = &#123;1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5&#125;;</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">find</span>(arr, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3局部最小值"><a href="#4-3局部最小值" class="headerlink" title="4.3局部最小值"></a>4.3局部最小值</h4><p><strong>要求：arr，无序，相邻数一定不相等，时间复杂度&lt;O(N)。</strong></p>
<p><strong>局部最小定义：</strong></p>
<p>​	<strong>最左或右侧：0&lt;1，N-1&lt;N-2，0和N-1就是局部最小；</strong></p>
<p>​	<strong>中间：i&lt;i-1&amp;i&lt;i+1，i就是局部最小。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> @author : Song Jiaqi</span></span><br><span class="line"><span class="comment"> @date : 2022-08-10 12:24</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到任意一个局部最小值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//数组不为空且长度不为0</span></span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">NULL</span> || length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//0&lt;1，最左侧两个数</span></span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">1</span> || arr[<span class="number">0</span>] &lt; arr[<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//N-1&lt;N-2，最右侧两个数</span></span><br><span class="line">    <span class="keyword">if</span> (arr[length - <span class="number">1</span>] &lt; arr[length - <span class="number">2</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> length - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//0&gt;1&amp;N-1&gt;N-2,中间某个或某些位置必然存在局部最小值</span></span><br><span class="line">    <span class="type">int</span> low = <span class="number">0</span>, high = length - <span class="number">1</span>, m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        m = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[m] &gt; arr[m - <span class="number">1</span>]) &#123;</span><br><span class="line">            high = m - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[m] &gt; arr[m + <span class="number">1</span>]) &#123;</span><br><span class="line">            low = m + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">15</span>, <span class="number">24</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">1</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="type">int</span> l = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">findMin</span>(arr,l);</span><br><span class="line">    cout&lt;&lt;result&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二分查找不一定必须有序，当可以甩掉一边的数时就可以根据情况使用。</p>
<h2 id="二-认识O-NlogN-的排序"><a href="#二-认识O-NlogN-的排序" class="headerlink" title="二.认识O(NlogN)的排序"></a>二.认识O(NlogN)的排序</h2><h3 id="1-刨析递归行为和其时间复杂度的估算"><a href="#1-刨析递归行为和其时间复杂度的估算" class="headerlink" title="1.刨析递归行为和其时间复杂度的估算"></a>1.刨析递归行为和其时间复杂度的估算</h3><h4 id="1-1递归求数组最大值，系统是如何做的？"><a href="#1-1递归求数组最大值，系统是如何做的？" class="headerlink" title="1.1递归求数组最大值，系统是如何做的？"></a>1.1递归求数组最大值，系统是如何做的？</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> @author : Song Jiaqi</span></span><br><span class="line"><span class="comment"> @date : 2022-08-10 12:24</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">process</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//arr[l...r]上只有一个数，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr[l];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//二进制右移&gt;&gt;除2.左移&lt;&lt;乘2</span></span><br><span class="line">    <span class="type">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//二分递归</span></span><br><span class="line">    <span class="type">int</span> leftMax = <span class="built_in">process</span>(arr, l, mid);</span><br><span class="line">    <span class="type">int</span> rightMax = <span class="built_in">process</span>(arr, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="comment">//比较求最大值</span></span><br><span class="line">    <span class="keyword">if</span> (leftMax &gt; rightMax) &#123;</span><br><span class="line">        <span class="keyword">return</span> leftMax;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rightMax;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getMax</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">process</span>(arr, <span class="number">0</span>, length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">66</span>, <span class="number">45</span>, <span class="number">88</span>, <span class="number">100</span>&#125;;</span><br><span class="line">    <span class="type">int</span> length = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">getMax</span>(arr, length) &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于此处对中点的求解：</p>
<p>以下三行代码是等价的。</p>
<p><strong>int mid &#x3D; (l+r)&#x2F;2;</strong></p>
<p><strong>int mid &#x3D; l+(r-l)&#x2F;2;</strong></p>
<p><strong>int mid &#x3D; l+((r-l)&gt;&gt;2);</strong></p>
<h4 id="1-2Master公式"><a href="#1-2Master公式" class="headerlink" title="1.2Master公式"></a>1.2Master公式</h4><p><strong>T(N)&#x3D;a*T(N&#x2F;b)+O(N^d)，子递归需要是等规模的。</strong></p>
<p>1.1符合该公式，可以写为T(N)&#x3D;2*T(N&#x2F;2)+O(1)。</p>
<p>结论：</p>
<p>三个系数确定时，时间复杂度就可以确定。</p>
<p><strong>a.log(b,a)&gt;d—&gt;O(N^log(b,a))</strong></p>
<p><strong>b.log(b,a)&#x3D;d—&gt;O(N^d * logN)</strong></p>
<p><strong>c.log(b,a)<d--->O(N^d)</d---></strong></p>
<h3 id="2-归并排序"><a href="#2-归并排序" class="headerlink" title="2.归并排序"></a>2.归并排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> @author : Song Jiaqi </span></span><br><span class="line"><span class="comment"> @date : 2022-08-21 16:59  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Code02_MergeSort</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">mergeSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//健壮性</span></span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">NULL</span> || length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归过程</span></span><br><span class="line">        <span class="built_in">process</span>(arr, <span class="number">0</span>, length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">process</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">process</span>(arr, l, mid);</span><br><span class="line">        <span class="built_in">process</span>(arr, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">merge</span>(arr, l, mid, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> l, <span class="type">int</span> m, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//额外申请一个数组</span></span><br><span class="line">        <span class="type">int</span> *temp = <span class="keyword">new</span> <span class="type">int</span>[r - l + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> len = <span class="number">0</span>;<span class="comment">//temp</span></span><br><span class="line">        <span class="type">int</span> p1 = l;<span class="comment">//left</span></span><br><span class="line">        <span class="type">int</span> p2 = m + <span class="number">1</span>;<span class="comment">//right</span></span><br><span class="line">        <span class="comment">//左右两部分是否越界</span></span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= m &amp;&amp; p2 &lt;= r) &#123;</span><br><span class="line">            <span class="comment">//将较小值拷贝到temp数组中</span></span><br><span class="line">            temp[len++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//左右两部分谁没越界就把谁拷贝到数组里去</span></span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= m) &#123;</span><br><span class="line">            temp[len++] = arr[p1++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p2 &lt;= r) &#123;</span><br><span class="line">            temp[len++] = arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            arr[l + i] = temp[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;temp数组：&quot;</span>;</span><br><span class="line">        <span class="built_in">show</span>(temp, len);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;arr数组：&quot;</span>;</span><br><span class="line">        <span class="built_in">show</span>(arr, <span class="number">7</span>);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;====&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">delete</span>[] temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">202</span>, <span class="number">6</span>, <span class="number">301</span>, <span class="number">100</span>, <span class="number">38</span>, <span class="number">8</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="type">int</span> l = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">    Code02_MergeSort::<span class="built_in">mergeSort</span>(arr, l);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;归并排序后的结果为：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    Code02_MergeSort::<span class="built_in">show</span>(arr, l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果如下：</strong></p>
<p>202, 6, 301, 100, 38, 8, 1为arr原始数据</p>
<p><img src="img_6.png"></p>
<h4 id="2-1结论"><a href="#2-1结论" class="headerlink" title="2.1结论"></a>2.1结论</h4><p>1.归并排序的过程就是通过递归不断求中点，并对左右两边也求中点。</p>
<p>2.当不能在划分中点时，对其进行排序，将小的放在前面，大的放在后面。以此类推，</p>
<p>每次都会将两个有序的数组合为一个有序的数组。</p>
<h4 id="2-2时间复杂度"><a href="#2-2时间复杂度" class="headerlink" title="2.2时间复杂度"></a><strong>2.2时间复杂度</strong></h4><p>利用Master公式求解得T(N)&#x3D;2T(N&#x2F;2)+O(N)</p>
<p>其中a&#x3D;2,b&#x3D;2,d&#x3D;1，得出log(2,2)&#x3D;1，故归并排序时间复杂度为O(NlogN),由于申请了一个temp数组</p>
<p>来临时存储数据，故其额外空间复杂度为O(N)。</p>
<h4 id="2-3为什么是O-NlogN"><a href="#2-3为什么是O-NlogN" class="headerlink" title="2.3为什么是O(NlogN)?"></a>2.3为什么是O(NlogN)?</h4><p>​	相比选择，冒泡，插入排序为O(N2)，归并排序的比较行为没有被浪费，每一次的比较行为</p>
<p>都变成了一个有序的数组，下一次由该数组和另一个数组归并为更大的一个有序的数组，因此</p>
<p>这个比较行为信息是在不断传递的。</p>
<h4 id="2-4归并排序的扩展"><a href="#2-4归并排序的扩展" class="headerlink" title="2.4归并排序的扩展"></a>2.4归并排序的扩展</h4><h5 id="2-4-1小和问题"><a href="#2-4-1小和问题" class="headerlink" title="2.4.1小和问题"></a>2.4.1小和问题</h5><p>小和：一个数组中，每一个数左边比当前数小的数累加起来的和，叫做这个数组的小和。</p>
<p>eg:[1,3,4,2,5],小和&#x3D;0+1+(1+3)+1+(1+3+4+2)&#x3D;1+4+1+10&#x3D;16</p>
<p>思路：等价于右边有几个数比左边大，同时为了计算这个数的数量需要进行排序，可改写归并排序实现。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> @author : Song Jiaqi </span></span><br><span class="line"><span class="comment"> @date : 2022-08-26 10:35  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Code02_SmallSum</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">SmallSum</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">NULL</span> || length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">process</span>(arr, <span class="number">0</span>, length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//arr[l...r]既要排序又要求小和</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">process</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//小和由三部分组成</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">process</span>(arr, l, m) + <span class="built_in">process</span>(arr, m + <span class="number">1</span>, r) + <span class="built_in">merge</span>(arr, l, m, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> l, <span class="type">int</span> m, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> *temp = <span class="keyword">new</span> <span class="type">int</span>[r - l + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> p1 = l;</span><br><span class="line">        <span class="type">int</span> p2 = m + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>; <span class="comment">//保存小和</span></span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= m &amp;&amp; p2 &lt;= r) &#123;</span><br><span class="line">            result += arr[p1] &lt; arr[p2] ? (r - p2 + <span class="number">1</span>) * arr[p1] : <span class="number">0</span>;</span><br><span class="line">            temp[t++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= m) &#123;</span><br><span class="line">            temp[t++] = arr[p1++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p2 &lt;= m) &#123;</span><br><span class="line">            temp[t++] = arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; i++) &#123;</span><br><span class="line">            arr[l + i] = temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;temp数组：&quot;</span>;</span><br><span class="line">        <span class="built_in">show</span>(temp, t);</span><br><span class="line">        <span class="keyword">delete</span>[] temp;</span><br><span class="line">        std::cout &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">baoli</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">NULL</span> || length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> p = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = p + <span class="number">1</span>; j &lt; length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &gt; arr[p]) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">            result += count * arr[p];</span><br><span class="line">        &#125;</span><br><span class="line">        p++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> length = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> sum = Code02_SmallSum::<span class="built_in">SmallSum</span>(arr, length);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;归并排序--小和为：&quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> sum2 = <span class="built_in">baoli</span>(arr, length);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;暴力解法--小和为：&quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="img_7.png"></p>
<h5 id="2-4-2逆序对问题"><a href="#2-4-2逆序对问题" class="headerlink" title="2.4.2逆序对问题"></a>2.4.2逆序对问题</h5>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++,数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>C++图形库Qt-学习笔记(持续更新中...)</title>
    <url>/2022/08/17/QtNode/</url>
    <content><![CDATA[<h1 id="一-Clion中创建Qt类的相关模板"><a href="#一-Clion中创建Qt类的相关模板" class="headerlink" title="一.Clion中创建Qt类的相关模板"></a>一.Clion中创建Qt类的相关模板</h1><h2 id="1-原模板："><a href="#1-原模板：" class="headerlink" title="1.原模板："></a>1.原模板：</h2><h3 id="Qt-Class-Header-h"><a href="#Qt-Class-Header-h" class="headerlink" title="Qt Class Header.h"></a>Qt Class Header.h</h3><p>#parse(“C File Header.h”)<br>#[[#ifndef]]# ${INCLUDE_GUARD}<br>#[[#define]]# ${INCLUDE_GUARD}</p>
<p>#[[#include]]# &lt;${PARENT_CLASS}&gt;</p>
<p>${USER_BEGIN_NAMESPACE}<br>QT_BEGIN_NAMESPACE<br>namespace Ui { class ${NAME}; }<br>QT_END_NAMESPACE</p>
<p>class ${NAME} : public ${PARENT_CLASS} {<br>Q_OBJECT</p>
<p>public:<br>    explicit ${NAME}(QWidget *parent &#x3D; nullptr);<br>    ~${NAME}() override;</p>
<p>private:<br>    Ui::${NAME} *ui;<br>};<br>${USER_END_NAMESPACE}</p>
<p>#[[#endif]]# &#x2F;&#x2F;${INCLUDE_GUARD}</p>
<h3 id="Qt-class-cpp"><a href="#Qt-class-cpp" class="headerlink" title="Qt class.cpp"></a>Qt class.cpp</h3><p>#parse(“C File Header.h”)<br>&#x2F;&#x2F; You may need to build the project (run Qt uic code generator) to get “${UI_HEADER_FILENAME}” resolved</p>
<p>#[[#include]]# “${HEADER_FILENAME}”<br>#[[#include]]# “${UI_HEADER_FILENAME}”</p>
<p>${USER_BEGIN_NAMESPACE}<br>${NAME}::${NAME}(QWidget *parent) :<br>    ${PARENT_CLASS}(parent), ui(new Ui::${NAME}) {<br>    ui-&gt;setupUi(this);<br>}</p>
<p>${NAME}::~${NAME}() {<br>    delete ui;<br>}<br>${USER_END_NAMESPACE}&#96;</p>
<h2 id="2-普通模板："><a href="#2-普通模板：" class="headerlink" title="2.普通模板："></a>2.普通模板：</h2><h3 id="Qt-Class-Header-h-1"><a href="#Qt-Class-Header-h-1" class="headerlink" title="Qt Class Header.h"></a>Qt Class Header.h</h3><p>#parse(“C File Header.h”)</p>
<p>#[[#ifndef]]# ${INCLUDE_GUARD}<br>#[[#define]]# ${INCLUDE_GUARD}</p>
<p>#[[#include]]# &lt;${PARENT_CLASS}&gt;<br>#[[#include]]# “${UI_HEADER_FILENAME}”</p>
<p>class ${NAME} : public ${PARENT_CLASS} {</p>
<p>};</p>
<p>#[[#endif]]# &#x2F;&#x2F;${INCLUDE_GUARD}</p>
<h3 id="Qt-class-cpp-1"><a href="#Qt-class-cpp-1" class="headerlink" title="Qt class.cpp"></a>Qt class.cpp</h3><p>#parse(“C File Header.h”)</p>
<p>#[[#include]]# “${HEADER_FILENAME}”</p>
<h1 id="二-笔记"><a href="#二-笔记" class="headerlink" title="二.笔记"></a>二.笔记</h1><h2 id="1-中文乱码"><a href="#1-中文乱码" class="headerlink" title="1.中文乱码"></a>1.中文乱码</h2><p>1.全部改为utf-8编码，Qt5可以自动将utf-8编码转换为Unicode字符集<br>2.若编码为GBK,则可添加以下代码：<br>&#x2F;&#x2F;通过QTextCodec实现编码转换,创建编码对象<br>    QTextCodec *codec &#x3D; QTextCodec::codecForName(“GBK”);<br>&#x2F;&#x2F;在指定输出的字符前，对其进行转换<br>    QLabel label(codec-&gt;toUnicode(“我是标签”));</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*代码*/</span><br><span class="line">#include &lt;QApplication&gt;</span><br><span class="line">#include &lt;QLabel&gt;</span><br><span class="line">#include &lt;QPushButton&gt;</span><br><span class="line">#include &lt;QTextCodec&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[]) &#123;//arg参数 c命令行变量数量，v[]命令行变量的数组</span><br><span class="line">    //通过QTextCodec实现编码转换,创建编码对象</span><br><span class="line">    QTextCodec *codec = QTextCodec::codecForName(&quot;GBK&quot;);</span><br><span class="line">    //创建Qt应用程序对象</span><br><span class="line">    QApplication app(argc, argv);</span><br><span class="line">    //创建标签控件（图形对象）</span><br><span class="line">//    QLabel label(&quot;我是标签&quot;);//utf-8</span><br><span class="line">    QLabel label(codec-&gt;toUnicode(&quot;我是标签&quot;));</span><br><span class="line">    label.resize(400, 400);</span><br><span class="line"></span><br><span class="line">//    QPushButton button(&quot;我是按钮&quot;);//utf-8</span><br><span class="line">    QPushButton button(codec-&gt;toUnicode(&quot;我是按钮&quot;));</span><br><span class="line">    button.resize(200, 200);</span><br><span class="line"></span><br><span class="line">button.show();</span><br><span class="line">//显示标签控件</span><br><span class="line">label.show();</span><br><span class="line">//让应用程序进入事件循环</span><br><span class="line">return QApplication::exec();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-父窗口"><a href="#2-父窗口" class="headerlink" title="2.父窗口"></a>2.父窗口</h2><p>1.QWidget 所有用户界面对象的基类<br>2.QMainWindow(QWidget子类) 对话框窗口的基类<br>3.QDialog(QWidget子类) 提供一个有菜单条、工具栏、状态条的主应用程序窗口</p>
<ul>
<li>&#96;&#96;&#96;</li>
</ul>
<pre><code>/*代码*/
#include &lt;QWidget&gt;
#include &lt;QLabel&gt;
#include &lt;QPushButton&gt;
#include &lt;QApplication&gt;
</code></pre>
<p>  int main(int argc, char *argv[]) {<br>      QApplication app(argc, argv);<br>      QWidget w;<br>      &#x2F;<em>在栈区创建，编译器会自行销毁</em>&#x2F;<br>      &#x2F;&#x2F;创建标签控件，并停靠在父窗口<br>      QLabel label(“我是标签”, &amp;w);<br>      label.move(20, 40);<br>      label.show();<br>      &#x2F;&#x2F;创建按钮控件，并停靠在父窗口<br>      QPushButton button(“按钮”, &amp;w);<br>      button.move(50, 60);<br>      button.show();<br>      &#x2F;*在堆区创建，不需要且没有合适位置使用delete关键字进行销毁。Qt的父窗口对象销毁时，相关控件会自行销毁，</p>
<pre><code> * 因此不需要担心内存泄露问题*/
   //    QPushButton* button1 = new QPushButton(&quot;大按钮&quot;,&amp;w);
       auto button1 = new QPushButton(&quot;大按钮&quot;, &amp;w);
       button1-&gt;move(200, 60);
       button1-&gt;show();
       w.move(200, 100);
       w.resize(500, 300);
       w.show();
       return QApplication::exec();
   &#125;
</code></pre>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">## 3.信号和槽</span><br><span class="line"></span><br><span class="line">### 1.信号定义</span><br><span class="line"></span><br><span class="line">​    class XX:public QObject&#123;</span><br><span class="line">​        Q_OBJECT</span><br><span class="line">​    signals:</span><br><span class="line">​        void signal_func(...);//信号函数</span><br><span class="line">​    &#125;;</span><br><span class="line">​    注：信号函数只需写声明，不能写定义</span><br><span class="line"></span><br><span class="line">### 2.槽定义</span><br><span class="line"></span><br><span class="line">​    class XX:public QObject&#123;</span><br><span class="line">​            Q_OBJECT</span><br><span class="line">​    public slots:</span><br><span class="line">​        void slot_func(...);//信号函数</span><br><span class="line">​    &#125;;</span><br><span class="line">​    注：</span><br><span class="line">​    a.槽函数可以连接到某个信号上，当信号被发射时，槽函数将被触发和执行</span><br><span class="line">​    b.槽函数也可当作普通的成员函数直接调用</span><br><span class="line"></span><br><span class="line">### 3.信号和槽连接</span><br><span class="line"></span><br><span class="line">QObject::connect(const QObject* sender,const char* signal,</span><br><span class="line">                const QObject* receiver,const char* method);</span><br><span class="line">参数：</span><br><span class="line">    sender：信号发送对象指针</span><br><span class="line">    signal：要发送的信号函数，可以使用“SIGNAL(...)”宏进行类型转换</span><br><span class="line">    receiver：信号的接收对象指针</span><br><span class="line">    method：接收信号后要执行的槽函数，可以使用“SLOT(...)”宏进行类型转换</span><br><span class="line">语法：</span><br><span class="line">1.信号和槽函数参数要一致</span><br><span class="line">2.可带有缺省参数（比如int x=0）</span><br><span class="line">3.信号函数的参数可以多于槽函数</span><br><span class="line">应用：</span><br><span class="line">1.一对多：执行顺序不确定，需要看系统的调度策略</span><br><span class="line">    QObject::connect(A,SIGNAL(signfun(int)),B1,SLOT(slotfun1(int)));</span><br><span class="line">    QObject::connect(A,SIGNAL(signfun(int)),B2,SLOT(slotfun2(int)));</span><br><span class="line">2.多对一</span><br><span class="line">    QObject::connect(A1,SIGNAL(signfun1(int)),B,SLOT(slotfun(int)));</span><br><span class="line">    QObject::connect(A2,SIGNAL(signfun2(int)),B,SLOT(slotfun(int)));</span><br><span class="line">3.信号级联（不常用，了解即可）</span><br><span class="line">    QObject::connect(A,SIGNAL(signfun(int)),B,SLOT(slotfun(int)));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&#x2F;<em>代码</em>&#x2F;<br>a.<br>&#x2F;&#x2F;信号和槽—点击按钮关闭标签<br>    &#x2F;&#x2F;QObject::connect(按钮指针，按钮信号，标签指针，标签信号)，SIGNAL和SLOT可以将字符串转化为const char*<br>    QObject::connect(&amp;button, SIGNAL(clicked()),&amp;label, SLOT(close()));<br>&#x2F;&#x2F;信号和槽—增加一个退出按钮，点击后退出应用程序<br>    QPushButton exit(“退出”,&amp;w);<br>    exit.move(150,60);<br>    exit.show();<br>    QObject::connect(&amp;exit,SIGNAL(clicked()),<br>                    &#x2F;<em>在本程序中有三种方式可供关闭应用程序</em>&#x2F;<br>&#x2F;&#x2F;                     &amp;app, SLOT(closeAllWindows()));<br>                     &amp;app, SLOT(quit()));<br>                    &#x2F;&#x2F;当父窗口被关闭了，其包含的所有控件都会被关闭，同时导致事件循环结束<br>&#x2F;&#x2F;                     &amp;w, SLOT(close()));</p>
<p>b.通过信号和槽来实现滑块和取值框的同步<br>#include <QWidget><br>#include <QSlider><br>#include <QSpinBox><br>#include <QApplication></QApplication></QSpinBox></QSlider></QWidget></p>
<p>int main(int argc, char *argv[]) {<br>    QApplication app(argc, argv);<br>    &#x2F;&#x2F;创建父窗口<br>    QWidget parent;<br>    parent.resize(400, 300);<br>    parent.show();<br>    &#x2F;&#x2F;创建水平滑块,水平的：Horizontal，垂直的：Vertical<br>    QSlider slider(Qt::Horizontal, &amp;parent);<br>    slider.move(50, 100);<br>    slider.resize(100, 50);<br>    &#x2F;&#x2F;设置取值范围<br>    slider.setRange(0, 999);<br>    slider.show();<br>    &#x2F;&#x2F;创建选值框<br>    QSpinBox spinBox(&amp;parent);<br>    spinBox.move(250, 100);<br>    spinBox.resize(100, 50);<br>    &#x2F;&#x2F;设置取值范围<br>    spinBox.setRange(0, 999);<br>    spinBox.show();<br>    &#x2F;&#x2F;块动值动<br>    QObject::connect(&amp;slider, SIGNAL(valueChanged(int)), &amp;spinBox, SLOT(setValue(int)));<br>    &#x2F;&#x2F;值动块动<br>    QObject::connect(&amp;spinBox, SIGNAL(valueChanged(int)), &amp;slider, SLOT(setValue(int)));<br>    return QApplication::exec();<br>}</p>
<h1 id="三-Qt事件处理机制"><a href="#三-Qt事件处理机制" class="headerlink" title="三.Qt事件处理机制"></a>三.Qt事件处理机制</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h2><h3 id="1-1什么是事件？"><a href="#1-1什么是事件？" class="headerlink" title="1.1什么是事件？"></a>1.1什么是事件？</h3><p><img src="img_0.png"></p>
<h3 id="1-2如何处理事件？"><a href="#1-2如何处理事件？" class="headerlink" title="1.2如何处理事件？"></a>1.2如何处理事件？</h3><p><img src="img_1.png"></p>
<h3 id="1-3如何重写事件？"><a href="#1-3如何重写事件？" class="headerlink" title="1.3如何重写事件？"></a>1.3如何重写事件？</h3><p><img src="img_2.png"></p>
<h2 id="2-分类"><a href="#2-分类" class="headerlink" title="2.分类"></a>2.分类</h2><h3 id="2-1绘图事件"><a href="#2-1绘图事件" class="headerlink" title="2.1绘图事件"></a>2.1绘图事件</h3><h4 id="2-1-1概念"><a href="#2-1-1概念" class="headerlink" title="2.1.1概念"></a>2.1.1概念</h4><p><img src="img_3.png"></p>
<h4 id="2-1-2具体操作流程"><a href="#2-1-2具体操作流程" class="headerlink" title="2.1.2具体操作流程"></a>2.1.2具体操作流程</h4><h5 id="图片存放"><a href="#图片存放" class="headerlink" title="-图片存放-"></a>-图片存放-</h5><p>a.在项目根目录创建images文件夹用于存放需要用到的图片，建议格式统一eg:1.jpg，2.jpg，目的是方便利用Index索引调用图片。</p>
<p>b.除此之外，还应创建一个.qrc文件，qrc是Qt的资源文件，格式模板如下：</p>
<p>prefix表示前缀</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;RCC&gt;</span><br><span class="line">    &lt;qresource prefix=&quot;&quot;&gt;</span><br><span class="line">        &lt;file&gt;&lt;/file&gt;</span><br><span class="line">    &lt;/qresource&gt;</span><br><span class="line">&lt;/RCC&gt;</span><br></pre></td></tr></table></figure>

<h5 id="图标设置和自定义"><a href="#图标设置和自定义" class="headerlink" title="-图标设置和自定义-"></a>-图标设置和自定义-</h5><p>a.需要准备一个图标，将其命名为logo.ico或者自定义名.ico，如果没有图标文件，可以在这个网站进行图片到图标的转换：</p>
<p>PNG转ICO - 在线转换图标文件：<a href="https://www.aconvert.com/cn/icon/png-to-ico/%EF%BC%88ctrl+%E9%BC%A0%E6%A0%87%E5%B7%A6%E9%94%AE%E7%82%B9%E5%87%BB%E8%AE%BF%E9%97%AE%EF%BC%89">https://www.aconvert.com/cn/icon/png-to-ico/（ctrl+鼠标左键点击访问）</a></p>
<p>b.需要一个.rc文件，模板如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id ICON</span><br><span class="line">&quot;logo.ico&quot;   //添加图标</span><br><span class="line">#include &lt;winver.h&gt;</span><br><span class="line"></span><br><span class="line">VS_VERSION_INFO</span><br><span class="line">VERSIONINFO</span><br><span class="line">        FILEVERSION</span><br><span class="line">1,0,0,10</span><br><span class="line">PRODUCTVERSION 1,0,0,10</span><br><span class="line">FILEFLAGSMASK 0x3fL</span><br><span class="line">#ifdef _DEBUG</span><br><span class="line">FILEFLAGS VS_FF_DEBUG</span><br><span class="line">#endif</span><br><span class="line">FILEOS VOS__WINDOWS32</span><br><span class="line">FILETYPE VFT_DLL</span><br><span class="line">FILESUBTYPE 0x0L</span><br><span class="line">BEGIN</span><br><span class="line">        BLOCK</span><br><span class="line">&quot;StringFileInfo&quot;</span><br><span class="line">BEGIN</span><br><span class="line">        BLOCK</span><br><span class="line">&quot;080404b0&quot;  //支持中文</span><br><span class="line">BEGIN</span><br><span class="line">/*文件说明*/ VALUE</span><br><span class="line">&quot;CompanyName&quot;, &quot;PgmTop有限公司\0&quot;</span><br><span class="line">/*文件说明*/ VALUE &quot;FileDescription&quot;, &quot;一款用于查看存放好的图片的简易浏览器\0&quot;</span><br><span class="line">/*文件版本*/ VALUE &quot;ProductName&quot;, &quot;图片浏览器\0&quot;</span><br><span class="line">/*产品名称*/ VALUE &quot;FileVersion&quot;, &quot;1.0\0&quot;</span><br><span class="line">/*产品版本*/ VALUE &quot;ProductVersion&quot;, &quot;1.0\0&quot;</span><br><span class="line">/*版权*/ VALUE &quot;LegalCopyright&quot;, &quot;版权所有 (C) PgmTop有限公司\0&quot;</span><br><span class="line">/*合法商标*/ VALUE &quot;LegalTrademarks&quot;, &quot;PgmTop有限公司\0&quot;</span><br><span class="line">/*原始文件名*/ VALUE &quot;OriginalFilename&quot;, &quot;demo.exe\0&quot;</span><br><span class="line">/*内部文件名*/ VALUE &quot;InternalName&quot;, &quot;demo.exe\0&quot;</span><br><span class="line">END</span><br><span class="line">        END</span><br><span class="line"></span><br><span class="line">BLOCK &quot;VarFileInfo&quot;</span><br><span class="line">BEGIN</span><br><span class="line">        VALUE</span><br><span class="line">&quot;Translation&quot;, 0x804, 1200  //语言-简体中文</span><br><span class="line">END</span><br><span class="line">        END</span><br></pre></td></tr></table></figure>

<p>c.只完成ab两步，生成的exe文件描述会有乱码，这是编码的问题。.rc文件默认utf-8编码，直接将其在Notepad++中选择左上方编码，然后转为ANSI编码即可。</p>
<p>d.通过a和b我们已经设置好了应用图标，但是生成的QApplication应用仍然是无图标状态，可以通过以下代码进行设置</p>
<p><strong>.&#x2F;:当前项目目录</strong></p>
<p><strong>..&#x2F;:上一级的项目目录</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;QIcon&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">si.setWindowIcon(QIcon(&quot;../xxx/xxx.ico&quot;));</span><br></pre></td></tr></table></figure>

<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="-注意事项-"></a>-注意事项-</h5><p>a.不要忘记将.qrc和.rc文件添加到CMakeLists.txt的add_executable()中去。</p>
<p>b.出现问题：</p>
<p>在将生成的exe文件封装打包后，点击运行生成的QApplication应用仍存在无图标，只有在构建运行的环境下才能正常显示。</p>
<p><strong>解决方案及原因：</strong></p>
<p>​	<strong>原因：</strong>这是因为在clion编程环境中，工作目录为cmake-build-debug，所有的.exe文件会在该目录下生成。所以在不改变我们的工作目</p>
<p>录情况下，我们采用了这种方式*<code>si.setWindowIcon(QIcon(&quot;../xxx/xxx.ico&quot;));</code>*，也就是从工作目录返回到项目目录，在项目目录下</p>
<p>查找我们自己创建的目录下的文件。</p>
<p>​	<strong>解决方案：</strong><code>si.setWindowIcon(QIcon(&quot;./xxx/xxx.ico&quot;));</code>将**..&#x2F;<strong>换为</strong>.&#x2F;**,并在已经封装好的.exe文件目录下创建文件夹xxx&#x2F;xxx.ico，</p>
<p>这样我们就能在生成的QApplication下看到我们设置的图标啦！</p>
<h5 id="效果展示"><a href="#效果展示" class="headerlink" title="-效果展示-"></a>-效果展示-</h5><p><strong>应用图标及信息</strong></p>
<p><img src="icon_0.png"></p>
<p><img src="icon_1.png"></p>
<p><strong>程序输出窗口</strong></p>
<p><img src="icon_2.png"></p>
<p><strong>QApplication窗口图标</strong></p>
<p><img src="icon_3.png" alt="十三点"></p>
<h3 id="2-2定时器事件"><a href="#2-2定时器事件" class="headerlink" title="2.2定时器事件"></a>2.2定时器事件</h3><p><img src="img_4.png"></p>
<h3 id="2-3鼠标和键盘事件"><a href="#2-3鼠标和键盘事件" class="headerlink" title="2.3鼠标和键盘事件"></a>2.3鼠标和键盘事件</h3>]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>C++,Qt</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2022/08/29/%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><h2 id="1-删除顺序表中最小值"><a href="#1-删除顺序表中最小值" class="headerlink" title="1.删除顺序表中最小值"></a>1.删除顺序表中最小值</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*删除顺序表中最小值*/</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int deleteMin(int *arr, int len) &#123;</span><br><span class="line">    if (arr == nullptr || len == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int minIndex = 0;</span><br><span class="line">    for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        minIndex = arr[minIndex] &lt; arr[i] ? minIndex : i;</span><br><span class="line">    &#125;</span><br><span class="line">    int result = arr[minIndex];</span><br><span class="line">    *(arr + minIndex) = *(arr + len - 1);</span><br><span class="line">    *(arr + len - 1) = 0;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int len;</span><br><span class="line">    int *arr = new int[len];</span><br><span class="line">    cout &lt;&lt; &quot;输入数组的长度：&quot;;</span><br><span class="line">    cin &gt;&gt; len;</span><br><span class="line">    for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; deleteMin(arr, len) &lt;&lt; endl;</span><br><span class="line">    for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-双指针反转数组"><a href="#2-双指针反转数组" class="headerlink" title="2.双指针反转数组"></a>2.双指针反转数组</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*双指针反转数组*/</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void reverseList(int *arr, int len) &#123;</span><br><span class="line">    int begin = 0;</span><br><span class="line">    int end = len - 1;</span><br><span class="line">    for (int i = 0; i &lt; len / 2; i++) &#123;</span><br><span class="line">        int temp = arr[begin];</span><br><span class="line">        arr[begin++] = arr[end];</span><br><span class="line">        arr[end--] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int len = 0;</span><br><span class="line">    int *arr = new int[len];</span><br><span class="line">    cout &lt;&lt; &quot;输入数组的长度：&quot;;</span><br><span class="line">    cin &gt;&gt; len;</span><br><span class="line">    for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    reverseList(arr, len);</span><br><span class="line">    for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="image-20220829172226058.png" alt="image-20220829172226058"></p>
<h2 id="3-删除数组指定值"><a href="#3-删除数组指定值" class="headerlink" title="3.删除数组指定值"></a>3.删除数组指定值</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*删除数组指定值*/</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void deleteValue(int *arr, int len, int value) &#123;</span><br><span class="line">    int temp = 0;</span><br><span class="line">    int index = 0;</span><br><span class="line">    while (index &lt; len) &#123;</span><br><span class="line">        if (*(arr + index) == value) &#123;</span><br><span class="line">            temp++; //temp即是与value相对的数的数量，也是其他与value不相等的数需要移动的次数</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            *(arr + index - temp) = *(arr + index);</span><br><span class="line">        &#125;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    //与value不相等的数迁移后，就将多余的数置零</span><br><span class="line">    for (int i = 0; i &lt; temp; i++) &#123;</span><br><span class="line">        *(arr + len - 1 - i) = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void show(int *arr, int len) &#123;</span><br><span class="line">    for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int arr[] = &#123;1, 2, 3, 5, 2, 2, 2&#125;;</span><br><span class="line">    int len = sizeof(arr) / sizeof(int);</span><br><span class="line">    show(arr, len);</span><br><span class="line">    deleteValue(arr, len, 2);</span><br><span class="line">    show(arr, len);</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="image-20220829175408267.png" alt="image-20220829175408267"></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2022/08/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="王道考研-数据结构笔记"><a href="#王道考研-数据结构笔记" class="headerlink" title="王道考研-数据结构笔记"></a>王道考研-数据结构笔记</h1><h2 id="一-关于-amp-的使用，它会返回修改的结果"><a href="#一-关于-amp-的使用，它会返回修改的结果" class="headerlink" title="一.关于&amp;的使用，它会返回修改的结果"></a>一.关于&amp;的使用，它会返回修改的结果</h2><p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">	x = <span class="number">1024</span>;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;test1: &quot;</span>&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	x = <span class="number">1024</span>;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;test: &quot;</span>&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">	cout&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">	<span class="comment">//test(x);</span></span><br><span class="line">	<span class="built_in">test1</span>(x);</span><br><span class="line">	cout&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="image-20220828222517653.png" alt="image-20220828222517653"></p>
<p><img src="image-20220828222630571.png" alt="image-20220828222630571"></p>
<h2 id="二-顺序表的定义"><a href="#二-顺序表的定义" class="headerlink" title="二.顺序表的定义"></a>二.顺序表的定义</h2><h3 id="2-1静态分配顺序表"><a href="#2-1静态分配顺序表" class="headerlink" title="2.1静态分配顺序表"></a>2.1静态分配顺序表</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10 <span class="comment">//定义最大长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> data[MaxSize]; <span class="comment">//定义一个静态数组存放数据元素</span></span><br><span class="line">	<span class="type">int</span> length; <span class="comment">//顺序表当前长度</span></span><br><span class="line">&#125;Seqlist; <span class="comment">//顺序表类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//基本操作-初始化一个顺序表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(Seqlist &amp;l)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;MaxSize;i++)&#123;</span><br><span class="line">		l.data[i]=<span class="number">0</span>; <span class="comment">//将所有数据元素设置为0</span></span><br><span class="line">	&#125;</span><br><span class="line">	l.length=<span class="number">0</span>; <span class="comment">//设置顺序表初始长度为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	Seqlist l;</span><br><span class="line">	InitList(l);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;MaxSize;i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,l.data[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-2动态分配顺序表"><a href="#2-2动态分配顺序表" class="headerlink" title="2.2动态分配顺序表"></a>2.2动态分配顺序表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#define InitSize 10 </span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">	int *data; //指示动态分配数组的指针</span><br><span class="line">	int MaxSize;</span><br><span class="line">	int length; //顺序表当前长度</span><br><span class="line">&#125;Seqlist; //顺序表类型定义</span><br><span class="line"></span><br><span class="line">//基本操作-初始化一个顺序表</span><br><span class="line">void InitList(Seqlist &amp;l)&#123;</span><br><span class="line">	l.data=(int *)malloc(InitSize * sizeof(int));</span><br><span class="line">	l.length=0; //设置顺序表初始长度为0</span><br><span class="line">	l.MaxSize=InitSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void IncreaseSize(Seqlist &amp;l,int len)&#123;</span><br><span class="line">	int *p=l.data;</span><br><span class="line">	l.data=(int *)malloc((l.MaxSize+len) * sizeof(int));</span><br><span class="line">	for(int i=0;i&lt;l.length;i++)&#123;</span><br><span class="line">		l.data[i]=p[i];</span><br><span class="line">	&#125;</span><br><span class="line">	l.MaxSize = l.MaxSize+len;</span><br><span class="line">	free(p);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	Seqlist l;</span><br><span class="line">	InitList(l);</span><br><span class="line">	IncreaseSize(l,5);</span><br><span class="line">	printf(&quot;%d\n&quot;,l.MaxSize);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="image-20220829134945636.png" alt="image-20220829134945636"></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2022/09/02/%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><h2 id="1-Fibornacci"><a href="#1-Fibornacci" class="headerlink" title="1.Fibornacci"></a>1.Fibornacci</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*暴力递归---时间复杂度为O(2^n)*/</span><br><span class="line">int fib(int num) &#123;</span><br><span class="line">    if (num == 1 || num == 2) return 1;</span><br><span class="line">    return fib(num - 1) + fib(num - 2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*自顶向下的递归解法---时间复杂度为O(n)*/</span><br><span class="line">int help(vector&lt;int&gt; &amp;memo, int n) &#123;</span><br><span class="line">    if (n == 1 || n == 2) return 1;</span><br><span class="line">    //在自顶向下递归过程已经算出memo[n]的值，并将其输出</span><br><span class="line">    if (memo[n] != 0) return memo[n];</span><br><span class="line">    //自顶向下的递归，并将子递归结果返回</span><br><span class="line">    memo[n] = help(memo, n - 1) + help(memo, n - 2);</span><br><span class="line">    return memo[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int fib2(int num) &#123;</span><br><span class="line">    if (num &lt; 1) return 0;</span><br><span class="line">    vector&lt;int&gt; memo(num + 1, 0);    //备忘录初始化</span><br><span class="line">    return help(memo, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*自底向上的dpTable---时间复杂度为O(n)*/</span><br><span class="line">int fib3(int num) &#123;</span><br><span class="line">    vector&lt;int&gt; dp(num + 1, 0);</span><br><span class="line">    dp[1] = dp[2] = 1;</span><br><span class="line">    for (int i = 3; i &lt;= num; i++) &#123;</span><br><span class="line">        dp[i] = dp[i - 1] + dp[i - 2];</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[num];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*fib3的优化，只保留前两个状态*/</span><br><span class="line">int fib4(int num) &#123;</span><br><span class="line">    if (num == 1 || num == 2) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    int prev = 1, curr = 1;</span><br><span class="line">    for (int i = 3; i &lt;= num; i++) &#123;</span><br><span class="line">        int sum = prev + curr;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    return curr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-Longest-Increment-Subsequence"><a href="#2-Longest-Increment-Subsequence" class="headerlink" title="2.Longest Increment Subsequence"></a>2.Longest Increment Subsequence</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//求最长递增子序列</span><br><span class="line">int lengthOfLIS(vector&lt;int&gt; nums) &#123;</span><br><span class="line">    vector&lt;int&gt; dp(nums.size(), 1); //子序列肯定包括自己，将其全部初始化为1</span><br><span class="line">    //求出dp数组</span><br><span class="line">    for (int i = 0; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;nums[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot; &lt;&lt; nums[i] &lt;&lt; &quot;, &quot;;</span><br><span class="line">        for (int j = 0; j &lt; i; j++) &#123;</span><br><span class="line">            if (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">//                dp[i] = dp[j] + 1;</span><br><span class="line">                dp[i] = max(dp[i], dp[j] + 1); //可能会有多个子序列，取最长的那一个序列放到dp数组中</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; &quot;dp[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot; &lt;&lt; dp[i] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int res = 0;</span><br><span class="line">    for (int i = 0; i &lt; dp.size(); i++) &#123;</span><br><span class="line">        res = max(res, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void test01() &#123;</span><br><span class="line">    vector&lt;int&gt; nums = &#123;1, 4, 3, 4, 5, 2, 3&#125;;</span><br><span class="line">    int res = lengthOfLIS(nums);</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">    test01();</span><br><span class="line"></span><br><span class="line">//    system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-isPrime"><a href="#3-isPrime" class="headerlink" title="3.isPrime?"></a>3.isPrime?</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cmath&gt; //sqrt()的头文件</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void isPrime(int n);</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int N = 0;</span><br><span class="line">	cin &gt;&gt; N;</span><br><span class="line">	for (int i = 2; i &lt;= N; i++) &#123;</span><br><span class="line">		isPrime(i);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void isPrime(int n) &#123;</span><br><span class="line">	int sqare = sqrt(n);</span><br><span class="line">	bool flag = true;</span><br><span class="line">	//使用平方根对数据进行简化后，i应该是&lt;=sqare，否则会出错</span><br><span class="line">	for (int i = 2; i &lt;= sqare; i++) &#123;</span><br><span class="line">		if (n % i == 0) &#123;</span><br><span class="line">			flag = false;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (flag) &#123;</span><br><span class="line">		cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2022/08/26/%E8%8B%B1%E8%AF%AD%E5%9B%9B%E7%BA%A7/</url>
    <content><![CDATA[<h1 id="英语四级"><a href="#英语四级" class="headerlink" title="英语四级"></a>英语四级</h1><h1 id="一-分值分布"><a href="#一-分值分布" class="headerlink" title="一.分值分布"></a>一.分值分布</h1><h2 id="1-写作-106-5分-15"><a href="#1-写作-106-5分-15" class="headerlink" title="1.写作 106.5分 15%"></a>1.写作 106.5分 15%</h2><h2 id="2-听力-248-5分-35"><a href="#2-听力-248-5分-35" class="headerlink" title="2.听力 248.5分 35%"></a>2.听力 248.5分 35%</h2><p>2.1A：新闻 7.1分&#x2F;题  *7</p>
<p>2.2B：长对话 7.1分&#x2F;题  *8</p>
<p>2.3C：文章 14.2分&#x2F;题  *10</p>
<h2 id="3-阅读理解-248-5分-35"><a href="#3-阅读理解-248-5分-35" class="headerlink" title="3.阅读理解 248.5分 35%"></a>3.阅读理解 248.5分 35%</h2><p>3.1A：选词填空 3.55分&#x2F;题  *10</p>
<p>3.2B：长篇阅读 7.1分&#x2F;题  *10</p>
<p>3.3C：仔细阅读 14.2分&#x2F;题  *10</p>
<h2 id="4-汉译英-106-5分-15"><a href="#4-汉译英-106-5分-15" class="headerlink" title="4.汉译英 106.5分 15%"></a>4.汉译英 106.5分 15%</h2><h1 id="二-成绩统计"><a href="#二-成绩统计" class="headerlink" title="二.成绩统计"></a>二.成绩统计</h1><h1 id="三-做题策略"><a href="#三-做题策略" class="headerlink" title="三.做题策略"></a>三.做题策略</h1><h1 id="四-作文总结"><a href="#四-作文总结" class="headerlink" title="四.作文总结"></a>四.作文总结</h1><h1 id="五-翻译总结"><a href="#五-翻译总结" class="headerlink" title="五.翻译总结"></a>五.翻译总结</h1><h2 id="5-1翻译思路"><a href="#5-1翻译思路" class="headerlink" title="5.1翻译思路"></a>5.1翻译思路</h2><p>1.英语与汉语不同，不一定要按照给出的汉语的断句方式来断英语</p>
<p>2.忽略汉语的定语，找到句子本体。</p>
<h2 id="5-2语义替换"><a href="#5-2语义替换" class="headerlink" title="5.2语义替换"></a>5.2语义替换</h2><p> 1.被称为&#x3D;因…出名</p>
<p>known as…</p>
<h2 id="5-3单词替换"><a href="#5-3单词替换" class="headerlink" title="5.3单词替换"></a>5.3单词替换</h2><p>1.综合体；结合体</p>
<p>combination&#x3D;synthesis</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2022/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
