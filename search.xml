<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>数据结构与算法-学习笔记(持续更新中...)</title>
    <url>/2022/08/17/AlgorithmNote/</url>
    <content><![CDATA[<h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><h2 id="关于如何使用Clion运行多个main函数？"><a href="#关于如何使用Clion运行多个main函数？" class="headerlink" title="关于如何使用Clion运行多个main函数？"></a>关于如何使用Clion运行多个main函数？</h2><p>用以下代码取代添加可执行文件代码：<code>add_executable(xxx xxx.cpp/h)</code>,对于每一个.cpp文件都会生成对应的.exe文件。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">#递归遍历所有的cpp文件</span><br><span class="line"><span class="built_in">file</span> (GLOB_RECURSE files *.cpp)</span><br><span class="line"></span><br><span class="line">#将所有的cpp文件单独生成可执行文件</span><br><span class="line">foreach (file $&#123;files&#125;)</span><br><span class="line"><span class="built_in">string</span>(REGEX REPLACE <span class="string">&quot;.+/(.+)\\..*&quot;</span> <span class="string">&quot;\\1&quot;</span> exe $&#123;file&#125;)</span><br><span class="line"><span class="built_in">add_executable</span> ($&#123;exe&#125; $&#123;file&#125;)</span><br><span class="line"><span class="built_in">message</span> (\ \ \ \ --\ src/$&#123;exe&#125;.cpp\ will\ be\ compiled\ to\ bin/$&#123;exe&#125;)</span><br><span class="line"><span class="built_in">endforeach</span> ()</span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<p>1.每次添加新文件后需要重新加载CMake项目。</p>
<p>2.这样修改适合使用Clion用于c++刷题。</p>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">method</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="一-认识复杂度和简单排序算法"><a href="#一-认识复杂度和简单排序算法" class="headerlink" title="一.认识复杂度和简单排序算法"></a>一.认识复杂度和简单排序算法</h2><h3 id="1-时间复杂度"><a href="#1-时间复杂度" class="headerlink" title="1.时间复杂度"></a>1.时间复杂度</h3><h4 id="1-1常数操作定义"><a href="#1-1常数操作定义" class="headerlink" title="1.1常数操作定义"></a>1.1常数操作定义</h4><p>一个操作如果和样本的数据量没有关系，每次都是固定时间内完成的操作，叫做常数操作。</p>
<h4 id="1-2求解时间复杂度"><a href="#1-2求解时间复杂度" class="headerlink" title="1.2求解时间复杂度"></a>1.2求解时间复杂度</h4><p>在算法流程中找出发生了多少常数操作，进而写出常数操作数量的表达式，取其最高项次数f(n),则时间复杂度为O(f(n))。</p>
<h4 id="1-3评价一个算法流程的好坏"><a href="#1-3评价一个算法流程的好坏" class="headerlink" title="1.3评价一个算法流程的好坏"></a>1.3评价一个算法流程的好坏</h4><p>先看时间复杂度，随后分析不同数据样本下的实际运行时间。</p>
<p>如下代码经多次运行测试，process2大部分情况下要比process1用时短。</p>
<p>原因：</p>
<p>1.加法-基本运算：异或操作。</p>
<p>2.减法-补码加运算：实际上加法也是补码加运算，只是在数据前用0表示正，1表示负。</p>
<p>3.乘法-移位相加。</p>
<p>4.除法-移位相减。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> @author : Song Jiaqi </span></span><br><span class="line"><span class="comment"> @date : 2022-08-10 12:24  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">process1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> N = <span class="number">1000</span>;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            a = <span class="number">2</span> + <span class="number">6</span>;</span><br><span class="line">            a = <span class="number">6</span> * <span class="number">9</span>;</span><br><span class="line">            a = <span class="number">8</span> * <span class="number">4</span>;</span><br><span class="line">            a = <span class="number">90</span> / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">process2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> N = <span class="number">1000</span>;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="comment">//位运算</span></span><br><span class="line">            a = <span class="number">2</span> | <span class="number">6</span>;</span><br><span class="line">            a = <span class="number">6</span> &amp; <span class="number">9</span>;</span><br><span class="line">            a = <span class="number">8</span> &amp; <span class="number">4</span>;</span><br><span class="line">            a = <span class="number">90</span> ^ <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> t1 = chrono::steady_clock::<span class="built_in">now</span>();<span class="comment">//获取开始时间</span></span><br><span class="line">    test::<span class="built_in">process1</span>();</span><br><span class="line">    <span class="keyword">auto</span> t2 = chrono::steady_clock::<span class="built_in">now</span>();<span class="comment">//获取结束时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> t3 = chrono::steady_clock::<span class="built_in">now</span>();<span class="comment">//获取开始时间</span></span><br><span class="line">    test::<span class="built_in">process2</span>();</span><br><span class="line">    <span class="keyword">auto</span> t4 = chrono::steady_clock::<span class="built_in">now</span>();<span class="comment">//获取结束时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    double rs = chrono::duration&lt;double&gt;(t2-t1).count();//s为单位</span></span><br><span class="line"><span class="comment">//    double rms = chrono::duration&lt;double,milli&gt;(t2 - t1).count();//ms为单位</span></span><br><span class="line">    <span class="type">double</span> rus1 = chrono::<span class="built_in">duration</span>&lt;<span class="type">double</span>, micro&gt;(t2 - t1).<span class="built_in">count</span>();<span class="comment">//us为单位</span></span><br><span class="line">    <span class="type">double</span> rus2 = chrono::<span class="built_in">duration</span>&lt;<span class="type">double</span>, micro&gt;(t4 - t3).<span class="built_in">count</span>();<span class="comment">//us为单位</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;process1: &quot;</span> &lt;&lt; rus1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;process2: &quot;</span> &lt;&lt; rus2 &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-选择排序和冒泡排序复杂度分析"><a href="#2-选择排序和冒泡排序复杂度分析" class="headerlink" title="2.选择排序和冒泡排序复杂度分析"></a>2.选择排序和冒泡排序复杂度分析</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> @author : Song Jiaqi </span></span><br><span class="line"><span class="comment"> @date : 2022-08-10 14:34  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//选择排序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Code01_selectionSort</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//1.每一次循环都能得出一个最大值或最小值，随后得到次大和次小值，以此类推</span></span><br><span class="line">    <span class="comment">//2.因为前面已经有序，最后一个不需要排序</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">selectionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">NULL</span> || length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一层循环确定循环的趟数(length-1)次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> minIndex = i;</span><br><span class="line">            <span class="comment">//第二层循环确定每一躺的最小值的下标</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; length; j++) &#123;</span><br><span class="line">                minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果minIndex发生改变就与i进行交换，否则自己与自己交换无意义</span></span><br><span class="line">            <span class="keyword">if</span> (minIndex != i) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(arr, i, minIndex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//方法一</span></span><br><span class="line"><span class="comment">//        int temp = arr[i];</span></span><br><span class="line"><span class="comment">//        arr[i] = arr[j];</span></span><br><span class="line"><span class="comment">//        arr[j] = temp;</span></span><br><span class="line">        <span class="comment">//方法二</span></span><br><span class="line">        arr[i] = arr[i] ^ arr[j];</span><br><span class="line">        arr[j] = arr[i] ^ arr[j];</span><br><span class="line">        arr[i] = arr[i] ^ arr[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Code01_bubbleSort</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//每躺循环都能找出一个最大值，同时循环范围总长度要减一</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">NULL</span> || length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> lastChangeIndex = <span class="number">0</span>;<span class="comment">//记录最后一次改变的下标</span></span><br><span class="line">        <span class="type">int</span> sortBorder = length - <span class="number">1</span>;<span class="comment">//记录无序数组的边界</span></span><br><span class="line">        <span class="comment">//第一层循环确定循环次数(length-1)次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> e = length - <span class="number">1</span>; e &gt; <span class="number">0</span>; e--) &#123;</span><br><span class="line">            <span class="type">bool</span> isSorted = <span class="literal">true</span>;<span class="comment">//定义该变量来判断是否有序，在有序情况下就不进行排序</span></span><br><span class="line">            <span class="comment">//第二层循环每相邻两个数做比较，并把较大数放到右边。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sortBorder; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                    isSorted = <span class="literal">false</span>;<span class="comment">//有元素交换说明无序</span></span><br><span class="line">                    Code01_selectionSort::<span class="built_in">swap</span>(arr, i, i + <span class="number">1</span>);</span><br><span class="line">                    lastChangeIndex = i + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sortBorder = lastChangeIndex;</span><br><span class="line">            <span class="comment">//一趟下来是否发生位置交换，如果没有交换直接跳出大循环</span></span><br><span class="line">            <span class="keyword">if</span> (isSorted) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环遍历数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == length - <span class="number">1</span>) &#123;</span><br><span class="line">            cout &lt;&lt; arr[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//    int a[] = &#123;1,3,2,6,5,8,10,9,5,2,6&#125;;</span></span><br><span class="line"><span class="comment">//    int a[] = &#123;1, 3, 6, 8, 10, 5, 2, 9&#125;;</span></span><br><span class="line"><span class="comment">//    int a[] = &#123;5, 8, 5, 2, 9&#125;;</span></span><br><span class="line">    <span class="type">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="type">int</span> length = <span class="built_in">sizeof</span>(a) / <span class="built_in">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">//    Code01_selectionSort::selectionSort(a, length);</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; &quot;选择排序后：&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//    show(a, length);</span></span><br><span class="line">    Code01_bubbleSort::<span class="built_in">bubbleSort</span>(a, length);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;冒泡排序后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">show</span>(a, length);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-1出现的问题"><a href="#2-1出现的问题" class="headerlink" title="2.1出现的问题"></a>2.1出现的问题</h4><p> **a.*<em>warning: ‘sizeof’ on array function parameter ‘arr’ will return size of ‘int</em>‘ [-Wsizeof-array-argument]</p>
<p>警告：数组函数参数“arr”上的“sizeof”将返回“int*”的大小[-Wsizeof-array-argument]</p>
<p>原因：C&#x2F;C++中如果一个函数接受一个数组作为参数，那么数组将会被退化为指针。</p>
<p>解决办法：在main函数中用<code>sizeof(array)/sizeof(array[0])</code>算好length，再将length传入函数中。</p>
<p>**b.**选择排序有误</p>
<p>原因：比较时使用的是arr[i]而不是arr[minIndex]，在minIndex发生多次变化时会出现排序错误，而i是始终不变的。以下面这个</p>
<p>数组为例，当i&#x3D;8,minIndex&#x3D;8，在遇到第一个比8小的5后minIndex会变为5.而i仍然是8，这就导致如果用的是i作为下标进行比较，</p>
<p>随后minIndex还会变为6，导致排序错误。</p>
<p>参考数组：<code>int a[] = &#123;1, 3, 6, 8, 10, 5, 2, 9&#125;;</code></p>
<p>修改前：<code>minIndex = arr[j] &lt; arr[i] ? j : minIndex;</code></p>
<p><img src="img.png"></p>
<p>修改后：<code>minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex;</code></p>
<p><img src="img_1.png"></p>
<h4 id="2-2总结"><a href="#2-2总结" class="headerlink" title="2.2总结"></a>2.2总结</h4><p>**a.**选择排序是不稳定的排序。</p>
<p>在一趟选择，如果一个元素比当前元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中两个5的相对前后顺序就被破坏了。</p>
<p>**b.**冒泡排序是稳定的排序。</p>
<p>如果相邻两个元素相等，是不会交换的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的相对前后顺序并没有改变。</p>
<p>**c.**选择排序和冒泡排序区别：</p>
<p>选择排序会在一趟中选择最大或最小值，然后将进行交换将其放到最右或最左边。</p>
<p>冒泡排序会在一趟中对相邻元素进行比较，一趟结束后最大值会到达最右边。</p>
<p>**d.**复杂度分析-时间复杂度O(n^2),额外空间复杂度O(1)—有限个变量。</p>
<p>选择排序：</p>
<p>0-n-1：最小的放第一个位置，比较n-1次</p>
<p>1-n-1：最小的放第二个位置，比较n-2次</p>
<p>……</p>
<p>冒泡排序：</p>
<p>第一趟比较n-1次</p>
<p>第二趟比较n-2次</p>
<p>第三趟比较n-3次</p>
<p>……</p>
<p>均成等差数列：<img src="img_2.png"></p>
<h4 id="2-3异或运算的理解"><a href="#2-3异或运算的理解" class="headerlink" title="2.3异或运算的理解"></a>2.3异或运算的理解</h4><h5 id="2-3-1关于异或"><a href="#2-3-1关于异或" class="headerlink" title="2.3.1关于异或"></a>2.3.1关于异或</h5><p>1.不相同为1，相同为0或无进位相加。<img src="img_3.png"></p>
<p>2.性质：</p>
<p>​	a.0^n&#x3D;n; n^n&#x3D;0;</p>
<p>​	b.满足交换和结合律。 </p>
<p>3.为什么通过异或可以交换a,b的值？</p>
<p><strong>前提：a，b在内存中为独立的内存区域，两者值可以相同，但两种指向的内存区域不能相同。</strong></p>
<p><img src="img_4.png"></p>
<p><strong>内存区域相同的后果：i和j位置不能相等，否则相当于同样的内存区域自己在和自己异或，会变为0。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">    cout&lt;&lt;arr[i]&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;arr[j]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    arr[i]=arr[i]^arr[j];</span><br><span class="line">    arr[j]=arr[i]^arr[j];</span><br><span class="line">    arr[i]=arr[i]^arr[j];</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;arr[i]&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;arr[j]&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="img_5.png"></p>
<h5 id="2-3-2题目：找到出现奇数次的数"><a href="#2-3-2题目：找到出现奇数次的数" class="headerlink" title="2.3.2题目：找到出现奇数次的数"></a>2.3.2题目：找到出现奇数次的数</h5><p>要求：时间O(n),空间O(1)</p>
<p>情况：</p>
<p>1.一种数出现奇数次，其他数出现偶数次</p>
<p><strong>异或运算与数的顺序无关，与其出现的次数的奇偶性有关，奇为1，偶为0。</strong></p>
<p>2.两种数出现奇数次，其他数出现偶数次</p>
<p><strong>a.这种情况下，从头到尾进行异或运算可以得到a^b，因为a!&#x3D;b，a^b!&#x3D;0。也就是说在某一位上a为1，b为0，或者是</strong></p>
<p><strong>b为1，a为0。</strong></p>
<p><strong>b.原码&amp;补码(~原码+1)&#x3D;一个数最右侧的1(rightOne)，而这个1出现的位置n就是我们要找的位置。</strong></p>
<p><strong>c.遍历数组先从头到尾进行与运算，此次对象为rightOne，而rigthOne除了位置n，其余位置均为0，也就是说其他数相与后结果必为0，</strong></p>
<p><strong>因此根据在n位置相与的结果为0和不为0，对数组中的数进行划分，而a和b就在这两组之一中。假设条件：相与后为0，每符合条件就</strong></p>
<p><strong>进行一次异或，偶数次的数会消掉，最终剩下a&#x2F;b。</strong></p>
<p><strong>d.用a^b即eor,和a&#x2F;b即onlyOne进行异或，就能得到a&#x2F;b。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> @author : Song Jiaqi </span></span><br><span class="line"><span class="comment"> @date : 2022-08-11 11:36  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1个数出现奇数次</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">num1</span><span class="params">(vector&lt;<span class="type">int</span>&gt; <span class="type">const</span> &amp;arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> eor = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> cur:arr) &#123;</span><br><span class="line">        eor ^= cur;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1个数出现奇数次：&quot;</span> &lt;&lt; eor &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2个数出现奇数次</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">num2</span><span class="params">(vector&lt;<span class="type">int</span>&gt; <span class="type">const</span> &amp;arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从头异或到尾得到eor=a^b</span></span><br><span class="line">    <span class="type">int</span> eor = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> cur:arr) &#123;</span><br><span class="line">        eor ^= cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//原码与补码相与得到一个数最右侧的1。</span></span><br><span class="line">    <span class="type">int</span> rightOne = eor &amp; (~eor + <span class="number">1</span>);<span class="comment">//~取反，取反+1得到补码。</span></span><br><span class="line">    <span class="type">int</span> onlyOne = <span class="number">0</span>;<span class="comment">//eor&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> cur:arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((cur &amp; rightOne) == <span class="number">0</span>) &#123;<span class="comment">//条件为==0或!=0</span></span><br><span class="line">            onlyOne ^= cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;2个数出现奇数次：&quot;</span> &lt;&lt; onlyOne &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (onlyOne ^ eor) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="built_in">num1</span>(arr);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr2 = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="built_in">num2</span>(arr2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-插入排序的讲解和复杂度分析"><a href="#3-插入排序的讲解和复杂度分析" class="headerlink" title="3.插入排序的讲解和复杂度分析"></a>3.插入排序的讲解和复杂度分析</h3><p>时间复杂度O(n^2),额外空间复杂度O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> @author : Song Jiaqi </span></span><br><span class="line"><span class="comment"> @date : 2022-08-17 09:40  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapIndex</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    arr[i] = arr[i] ^ arr[j];</span><br><span class="line">    arr[j] = arr[i] ^ arr[j];</span><br><span class="line">    arr[i] = arr[i] ^ arr[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">NULL</span> || length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//0-0已经有序，想让0-i有序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="comment">//j指向当前所在数的前一个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; arr[j + <span class="number">1</span>]; j--) &#123;</span><br><span class="line">            <span class="built_in">swapIndex</span>(arr, j, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showArr</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="type">int</span> l = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">    <span class="built_in">insertionSort</span>(arr, l);</span><br><span class="line">    <span class="built_in">showArr</span>(arr, l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-1对时间复杂度的补充说明"><a href="#3-1对时间复杂度的补充说明" class="headerlink" title="3.1对时间复杂度的补充说明"></a>3.1对时间复杂度的补充说明</h4><p>a.O();O代表最差时间复杂度，要考虑最坏情况。</p>
<p>b.eg:7654321</p>
<p>0-1 交换1个</p>
<p>0-2 交换2个</p>
<p>0-3 交换3个</p>
<p>……</p>
<p>成等差数列，因此时间复杂度为O(n^2)。</p>
<h3 id="4-二分法的详解与扩展"><a href="#4-二分法的详解与扩展" class="headerlink" title="4.二分法的详解与扩展"></a>4.二分法的详解与扩展</h3><h4 id="4-1在一个有序数组中找某个数是否存在？"><a href="#4-1在一个有序数组中找某个数是否存在？" class="headerlink" title="4.1在一个有序数组中找某个数是否存在？"></a>4.1在一个有序数组中找某个数是否存在？</h4><p>a.如果使用直接遍历，复杂度为O(n)。</p>
<p>b.采用二分法，如果有16个数，考虑最坏情况，可划分为8,4,2,1个，需要4次即log2 16，</p>
<p>复杂度为log2 N(一般将其写为logN)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> @author : Song Jiaqi</span></span><br><span class="line"><span class="comment"> @date : 2022-08-10 12:24</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find1</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i:arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == num) &#123;</span><br><span class="line">            cout &lt;&lt; num &lt;&lt; <span class="string">&quot;存在&quot;</span> &lt;&lt; endl;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; <span class="string">&quot;不存在&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二分查找</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find2</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> low = <span class="number">0</span>, high = arr.<span class="built_in">size</span>()<span class="number">-1</span>, mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == num) &#123;</span><br><span class="line">            cout &lt;&lt; num &lt;&lt; <span class="string">&quot;存在&quot;</span> &lt;&lt; endl;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; num) &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; <span class="string">&quot;不存在&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="comment">//    find1(arr, 88);</span></span><br><span class="line">    <span class="built_in">find2</span>(arr, <span class="number">11</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2在一个有序数组中找某个-gt-x3D-某个数最左侧的位置"><a href="#4-2在一个有序数组中找某个-gt-x3D-某个数最左侧的位置" class="headerlink" title="4.2在一个有序数组中找某个&gt;&#x3D;某个数最左侧的位置"></a>4.2在一个有序数组中找某个&gt;&#x3D;某个数最左侧的位置</h4><p>​	仍然可以使用二分查找法，只是相对于4.1来说循环结束条件会不同，4.1是找到数就退出，而4.2中满足的数有很多，需要找到最左侧哪一个，因此需要等待low不断递增或者high不断递减，直到low&gt;high。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> @author : Song Jiaqi </span></span><br><span class="line"><span class="comment"> @date : 2022-08-10 12:24  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> low = <span class="number">0</span>, high = arr.<span class="built_in">size</span>() - <span class="number">1</span>, mid = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> f1 = <span class="number">0</span>;<span class="comment">//记录符合要求的下标</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt;= num) &#123;</span><br><span class="line">            f1 = mid;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;找到&gt;=&quot;</span> &lt;&lt; num &lt;&lt; <span class="string">&quot;的下标为：&quot;</span> &lt;&lt; f1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//    vector&lt;int&gt; arr = &#123;1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5&#125;;</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">find</span>(arr, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3局部最小值"><a href="#4-3局部最小值" class="headerlink" title="4.3局部最小值"></a>4.3局部最小值</h4><p><strong>要求：arr，无序，相邻数一定不相等，时间复杂度&lt;O(N)。</strong></p>
<p><strong>局部最小定义：</strong></p>
<p>​	<strong>最左或右侧：0&lt;1，N-1&lt;N-2，0和N-1就是局部最小；</strong></p>
<p>​	<strong>中间：i&lt;i-1&amp;i&lt;i+1，i就是局部最小。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> @author : Song Jiaqi</span></span><br><span class="line"><span class="comment"> @date : 2022-08-10 12:24</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到任意一个局部最小值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//数组不为空且长度不为0</span></span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">NULL</span> || length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//0&lt;1，最左侧两个数</span></span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">1</span> || arr[<span class="number">0</span>] &lt; arr[<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//N-1&lt;N-2，最右侧两个数</span></span><br><span class="line">    <span class="keyword">if</span> (arr[length - <span class="number">1</span>] &lt; arr[length - <span class="number">2</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> length - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//0&gt;1&amp;N-1&gt;N-2,中间某个或某些位置必然存在局部最小值</span></span><br><span class="line">    <span class="type">int</span> low = <span class="number">0</span>, high = length - <span class="number">1</span>, m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        m = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[m] &gt; arr[m - <span class="number">1</span>]) &#123;</span><br><span class="line">            high = m - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[m] &gt; arr[m + <span class="number">1</span>]) &#123;</span><br><span class="line">            low = m + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">15</span>, <span class="number">24</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">1</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="type">int</span> l = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">findMin</span>(arr,l);</span><br><span class="line">    cout&lt;&lt;result&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二分查找不一定必须有序，当可以甩掉一边的数时就可以根据情况使用。</p>
<h2 id="二-认识O-NlogN-的排序"><a href="#二-认识O-NlogN-的排序" class="headerlink" title="二.认识O(NlogN)的排序"></a>二.认识O(NlogN)的排序</h2><h3 id="1-刨析递归行为和其时间复杂度的估算"><a href="#1-刨析递归行为和其时间复杂度的估算" class="headerlink" title="1.刨析递归行为和其时间复杂度的估算"></a>1.刨析递归行为和其时间复杂度的估算</h3><h4 id="1-1递归求数组最大值，系统是如何做的？"><a href="#1-1递归求数组最大值，系统是如何做的？" class="headerlink" title="1.1递归求数组最大值，系统是如何做的？"></a>1.1递归求数组最大值，系统是如何做的？</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> @author : Song Jiaqi</span></span><br><span class="line"><span class="comment"> @date : 2022-08-10 12:24</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">process</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//arr[l...r]上只有一个数，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr[l];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//二进制右移&gt;&gt;除2.左移&lt;&lt;乘2</span></span><br><span class="line">    <span class="type">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//二分递归</span></span><br><span class="line">    <span class="type">int</span> leftMax = <span class="built_in">process</span>(arr, l, mid);</span><br><span class="line">    <span class="type">int</span> rightMax = <span class="built_in">process</span>(arr, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="comment">//比较求最大值</span></span><br><span class="line">    <span class="keyword">if</span> (leftMax &gt; rightMax) &#123;</span><br><span class="line">        <span class="keyword">return</span> leftMax;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rightMax;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getMax</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">process</span>(arr, <span class="number">0</span>, length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">66</span>, <span class="number">45</span>, <span class="number">88</span>, <span class="number">100</span>&#125;;</span><br><span class="line">    <span class="type">int</span> length = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">getMax</span>(arr, length) &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于此处对中点的求解：</p>
<p>以下三行代码是等价的。</p>
<p><strong>int mid &#x3D; (l+r)&#x2F;2;</strong></p>
<p><strong>int mid &#x3D; l+(r-l)&#x2F;2;</strong></p>
<p><strong>int mid &#x3D; l+((r-l)&gt;&gt;2);</strong></p>
<h4 id="1-2Master公式"><a href="#1-2Master公式" class="headerlink" title="1.2Master公式"></a>1.2Master公式</h4><p><strong>T(N)&#x3D;a*T(N&#x2F;b)+O(N^d)，子递归需要是等规模的。</strong></p>
<p>1.1符合该公式，可以写为T(N)&#x3D;2*T(N&#x2F;2)+O(1)。</p>
<p>结论：</p>
<p>三个系数确定时，时间复杂度就可以确定。</p>
<p><strong>a.log(b,a)&gt;d—&gt;O(N^log(b,a))</strong></p>
<p><strong>b.log(b,a)&#x3D;d—&gt;O(N^d * logN)</strong></p>
<p><strong>c.log(b,a)<d--->O(N^d)</d---></strong></p>
<h3 id="2-归并排序"><a href="#2-归并排序" class="headerlink" title="2.归并排序"></a>2.归并排序</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> @author : Song Jiaqi </span></span><br><span class="line"><span class="comment"> @date : 2022-08-21 16:59  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//归并排序</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//健壮性</span></span><br><span class="line">        <span class="keyword">if</span> (arr.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">process</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行递归</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">process</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">process</span>(arr, l, mid);</span><br><span class="line">        <span class="built_in">process</span>(arr, mid + <span class="number">1</span>, r);</span><br><span class="line">        <span class="built_in">merge</span>(arr, l, mid, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行归并</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//申请额外的空间</span></span><br><span class="line">        <span class="type">int</span> *temp = <span class="keyword">new</span> <span class="type">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//定义指针</span></span><br><span class="line">        <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l = left;</span><br><span class="line">        <span class="type">int</span> r = mid + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//考虑是否越界，并拿出较小数</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= mid &amp;&amp; r &lt;= right) &#123;</span><br><span class="line">            temp[t++] = arr[l] &lt;= arr[r] ? arr[l++] : arr[r++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//谁没越界就把谁放到临时数组后面</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= mid) &#123;</span><br><span class="line">            temp[t++] = arr[l++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (r &lt;= right) &#123;</span><br><span class="line">            temp[t++] = arr[r++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把temp数组的数据放回arr数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; i++) &#123;</span><br><span class="line">            arr[left + i] = temp[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放内存</span></span><br><span class="line">        <span class="keyword">delete</span>[] temp;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环遍历vector数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = arr.<span class="built_in">begin</span>(); it != arr.<span class="built_in">end</span>(); it++) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; a = &#123;<span class="number">1</span>, <span class="number">65</span>, <span class="number">21</span>, <span class="number">35</span>, <span class="number">4654</span>, <span class="number">45</span>, <span class="number">12</span>, <span class="number">35</span>, <span class="number">356</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">34</span>, <span class="number">45</span>&#125;;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;归并排序前：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">show</span>(a);</span><br><span class="line">    Test::<span class="built_in">mergeSort</span>(a);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;归并排序后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">show</span>(a);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>运行结果如下：</strong></p>
<p><img src="image-20220926223012444.png" alt="image-20220926223012444"></p>
<h4 id="2-1结论"><a href="#2-1结论" class="headerlink" title="2.1结论"></a>2.1结论</h4><p>1.归并排序的过程就是通过递归不断求中点，并对左右两边也求中点。</p>
<p>2.当不能在划分中点时，对其进行排序，将小的放在前面，大的放在后面。以此类推，</p>
<p>每次都会将两个有序的数组合为一个有序的数组。</p>
<h4 id="2-2时间复杂度"><a href="#2-2时间复杂度" class="headerlink" title="2.2时间复杂度"></a><strong>2.2时间复杂度</strong></h4><p>利用Master公式求解得T(N)&#x3D;2T(N&#x2F;2)+O(N)</p>
<p>其中a&#x3D;2,b&#x3D;2,d&#x3D;1，得出log(2,2)&#x3D;1，故归并排序时间复杂度为O(NlogN),由于申请了一个temp数组</p>
<p>来临时存储数据，故其额外空间复杂度为O(N)。</p>
<h4 id="2-3为什么是O-NlogN"><a href="#2-3为什么是O-NlogN" class="headerlink" title="2.3为什么是O(NlogN)?"></a><strong>2.3为什么是O(NlogN)?</strong></h4><p>​	相比选择，冒泡，插入排序为O(N2)，归并排序的比较行为没有被浪费，每一次的比较行为</p>
<p>都变成了一个有序的数组，下一次由该数组和另一个数组归并为更大的一个有序的数组，因此</p>
<p>这个比较行为信息是在不断传递的。</p>
<p><strong>#### 2.4归并排序的扩展</strong></p>
<h5 id="2-4-1小和问题"><a href="#2-4-1小和问题" class="headerlink" title="2.4.1小和问题"></a>2.4.1小和问题</h5><p>小和：一个数组中，每一个数左边比当前数小的数累加起来的和，叫做这个数组的小和。</p>
<p>eg:[1,3,4,2,5],小和&#x3D;0+1+(1+3)+1+(1+3+4+2)&#x3D;1+4+1+10&#x3D;16</p>
<p>思路：等价于右边有几个数比左边大，同时为了计算这个数的数量需要进行排序，可改写归并排序实现。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> @author : Song Jiaqi </span></span><br><span class="line"><span class="comment"> @date : 2022-08-26 10:35  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Code02_SmallSum</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">SmallSum</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">NULL</span> || length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">process</span>(arr, <span class="number">0</span>, length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//arr[l...r]既要排序又要求小和</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">process</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> m = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//小和由三部分组成</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">process</span>(arr, l, m) + <span class="built_in">process</span>(arr, m + <span class="number">1</span>, r) + <span class="built_in">merge</span>(arr, l, m, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> l, <span class="type">int</span> m, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> *temp = <span class="keyword">new</span> <span class="type">int</span>[r - l + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> p1 = l;</span><br><span class="line">        <span class="type">int</span> p2 = m + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>; <span class="comment">//保存小和</span></span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= m &amp;&amp; p2 &lt;= r) &#123;</span><br><span class="line">            result += arr[p1] &lt; arr[p2] ? (r - p2 + <span class="number">1</span>) * arr[p1] : <span class="number">0</span>;</span><br><span class="line">            temp[t++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= m) &#123;</span><br><span class="line">            temp[t++] = arr[p1++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p2 &lt;= m) &#123;</span><br><span class="line">            temp[t++] = arr[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; i++) &#123;</span><br><span class="line">            arr[l + i] = temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;temp数组：&quot;</span>;</span><br><span class="line">        <span class="built_in">show</span>(temp, t);</span><br><span class="line">        <span class="keyword">delete</span>[] temp;</span><br><span class="line">        std::cout &lt;&lt; result &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="type">int</span> length = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> sum = Code02_SmallSum::<span class="built_in">SmallSum</span>(arr, length);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;归并排序--小和为：&quot;</span> &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="img_7.png"></p>
<h5 id="2-4-2逆序对问题"><a href="#2-4-2逆序对问题" class="headerlink" title="2.4.2逆序对问题"></a>2.4.2逆序对问题</h5><p>在一个数组中，左边比右边的数大，则这两个数构成一个逆序对，输出所有逆序对。</p>
<p><strong>与求小和问题相同，前者求左边比右边大，后者求左边比右边小。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">algorithm</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">getPair</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;vec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (vec.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">recursion</span>(vec, <span class="number">0</span>, vec.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recursion</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;vec, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left == right) <span class="keyword">return</span>;</span><br><span class="line">        <span class="type">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">recursion</span>(vec, left, mid);</span><br><span class="line">        <span class="built_in">recursion</span>(vec, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="built_in">merge</span>(vec, left, mid, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;vec, <span class="type">int</span> l, <span class="type">int</span> m, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//临时空间</span></span><br><span class="line">        <span class="type">int</span> *temp = <span class="keyword">new</span> <span class="type">int</span>[r - l + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//指针</span></span><br><span class="line">        <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> p1 = l;</span><br><span class="line">        <span class="type">int</span> p2 = m + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//三个while循环</span></span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= m &amp;&amp; p2 &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (vec[p1] &gt; vec[p2]) &#123;</span><br><span class="line">                temp[t++] = vec[p1++];</span><br><span class="line">                count += r - p2 + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                temp[t++] = vec[p2++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p1 &lt;= m) &#123;</span><br><span class="line">            temp[t++] = vec[p1++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (p2 &lt;= m) &#123;</span><br><span class="line">            temp[t++] = vec[p2++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//temp数组的数据放回</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; i++) &#123;</span><br><span class="line">            vec[l + i] = temp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; count &lt;&lt; endl;</span><br><span class="line">        <span class="comment">//释放内存空间</span></span><br><span class="line">        <span class="keyword">delete</span>[] temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;vec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i:vec) &#123;</span><br><span class="line">            cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">6</span>, <span class="number">100</span>, <span class="number">38</span>, <span class="number">202</span>, <span class="number">100</span>, <span class="number">301</span>, <span class="number">38</span>, <span class="number">8</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    algorithm a;</span><br><span class="line">    a.<span class="built_in">getPair</span>(arr);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;逆序对有：&quot;</span>&lt;&lt;a.count&lt;&lt;<span class="string">&quot;个&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <img src="image-20221004085230325.png" alt="image-20221004085230325"></p>
<h3 id="3-快速排序"><a href="#3-快速排序" class="headerlink" title="3.快速排序"></a>3.快速排序</h3><h4 id="3-1荷兰国旗问题"><a href="#3-1荷兰国旗问题" class="headerlink" title="3.1荷兰国旗问题"></a>3.1荷兰国旗问题</h4><ol>
<li>​	给定一个数组arr,和一个数num，请把小于等于num的数放在数组的左边，大于num的数放在数组的右边。要求<strong>额外空间复杂度0(1)，时间复杂度0 (N)</strong></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">algorithm</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> j = <span class="number">-1</span>; <span class="comment">//&lt;=区指针</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">//移动指针</span></span><br><span class="line">        <span class="keyword">for</span> (i; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt;= num) &#123;</span><br><span class="line">                <span class="comment">//i指向的数与&lt;=区不相等时才交换</span></span><br><span class="line">                <span class="keyword">if</span> (arr[i] != arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    arr[i] = arr[i] ^ arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[j + <span class="number">1</span>] = arr[i] ^ arr[j + <span class="number">1</span>];</span><br><span class="line">                    arr[i] = arr[i] ^ arr[j + <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                j++; <span class="comment">//把数放到&lt;=区，空间增一</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k:arr) &#123;</span><br><span class="line">            cout &lt;&lt; k &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">20</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">60</span>, <span class="number">50</span>, <span class="number">45</span>, <span class="number">99</span>, <span class="number">45</span>, <span class="number">12</span>, <span class="number">78</span>&#125;;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    cin &gt;&gt; num;</span><br><span class="line">    algorithm::<span class="built_in">sort</span>(arr, num);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="image-20221004110935150.png" alt="image-20221004110935150"></p>
<ol start="2">
<li><p>​	给定一个数组arr，和一个数num,请把小于num的数放在数组的左边，<strong>等于num的数放在数组的中间</strong>，大于num的数放在数组的右边。要求<strong>额外空间复杂度0(1)，时间复杂度0 (N)</strong></p>
<p><strong>思路：</strong>划分成三个区，从左右两边同时缩进，左边右扩，右边左扩，形成两军交接之势。</p>
<p><strong>与题目1的不同点：</strong>1.结束条件不同，本题变为了移动指针与大于区指针相遇，题目1会全部遍历一遍。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">algorithm</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> small = <span class="number">-1</span>; <span class="comment">//小于区</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">int</span> large = arr.<span class="built_in">size</span>(); <span class="comment">//大于区</span></span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>; <span class="comment">//移动指针</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (i != large) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; num) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i] != arr[small + <span class="number">1</span>]) &#123;</span><br><span class="line">                    arr[i] = arr[i] ^ arr[small + <span class="number">1</span>];</span><br><span class="line">                    arr[small + <span class="number">1</span>] = arr[i] ^ arr[small + <span class="number">1</span>];</span><br><span class="line">                    arr[i] = arr[i] ^ arr[small + <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                small++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt; num) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i] != arr[large - <span class="number">1</span>]) &#123;</span><br><span class="line">                    arr[i] = arr[i] ^ arr[large - <span class="number">1</span>];</span><br><span class="line">                    arr[large - <span class="number">1</span>] = arr[i] ^ arr[large - <span class="number">1</span>];</span><br><span class="line">                    arr[i] = arr[i] ^ arr[large - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                large--;</span><br><span class="line"><span class="comment">//                交换后，新的值还没看，i不需要++</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k:arr) &#123;</span><br><span class="line">            cout &lt;&lt; k &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    cin &gt;&gt; num;</span><br><span class="line">    algorithm::<span class="built_in">sort</span>(arr, num);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="XZDesktop/image-20221004181159351.png" alt="image-20221004181159351"></p>
</li>
</ol>
<h4 id="3-2快排1-0"><a href="#3-2快排1-0" class="headerlink" title="3.2快排1.0"></a>3.2快排1.0</h4><p>​	将数组中的最后一个数当作num，将前面的区域划分成&lt;&#x3D; region和&gt; region，最后再将最后一个数num与小于等于区域的后一个数交换。执行完上述操作（partion）后，num所在位置就是最终排序后所在的位置。让两个区域递归上述过程。</p>
<h4 id="3-3快排2-0"><a href="#3-3快排2-0" class="headerlink" title="3.3快排2.0"></a>3.3快排2.0</h4><p>将数组中的最后一个数当作num，将前面的区域划分成&lt;&#x3D; region, &#x3D; region和&gt; region，最后再将最后一个数num与大于区域的第一个数交换。执行完上述操作（partion）后，num所在位置就是最终排序后所在的位置。让小于区域和大于区域递归上述过程。快排2.0比快排1.0快一点，因为每次可以排好若干个相等的数。</p>
<p><strong>快排1.0和2.0的时间复杂度都是O(N2)，因为可以举出最坏的例子（给定数组就是排好序的数组）的时间复杂度是O(N2)。最好的情况是每次的划分值刚好在中间（时间复杂度为O(NlogN)），划分值很偏左&#x2F;右都是不好的情况</strong></p>
<h4 id="3-4快排3-0"><a href="#3-4快排3-0" class="headerlink" title="3.4快排3.0"></a>3.4快排3.0</h4><p>从数组中随机选择一个数与最后一个数交换，当成划分值。因为每次划分值都是随机选取的，因此可以保证时间复杂度就是O(NlogN)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">algorithm</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.<span class="built_in">size</span>() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//排序arr[l...r]</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="comment">//ger random num</span></span><br><span class="line">            <span class="built_in">srand</span>((<span class="type">unsigned</span>) <span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line">            <span class="type">int</span> x = <span class="built_in">rand</span>() % (r - l + <span class="number">1</span>) + l;</span><br><span class="line">            <span class="comment">//exchange value</span></span><br><span class="line">            <span class="built_in">swap</span>(arr[r], arr[x]);</span><br><span class="line">            <span class="comment">//Regional division</span></span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; p = <span class="built_in">partition</span>(arr, l, r);</span><br><span class="line">            <span class="comment">//next recursion</span></span><br><span class="line">            <span class="built_in">sort</span>(arr, l, p[<span class="number">0</span>] - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">sort</span>(arr, p[<span class="number">1</span>] + <span class="number">1</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//默认以arr[r]做划分，&lt;   ==   &gt;</span></span><br><span class="line">    <span class="comment">//返回=区域的左边界和右边界</span></span><br><span class="line">    <span class="function"><span class="type">static</span> vector&lt;<span class="type">int</span>&gt; <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> less = l - <span class="number">1</span>, more = r;<span class="comment">//less：&lt;区域右边界 more：&gt;区域的左边界</span></span><br><span class="line">        <span class="type">int</span> i = l;<span class="comment">//i：当前下标</span></span><br><span class="line">        <span class="type">int</span> num = arr[r];<span class="comment">//选定的划分值</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; more) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; num) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(arr[i], arr[less + <span class="number">1</span>]);</span><br><span class="line">                less++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt; num) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(arr[i], arr[more - <span class="number">1</span>]);</span><br><span class="line">                more--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(arr[r], arr[more]);</span><br><span class="line">        <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;less + <span class="number">1</span>, more&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i:arr) &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    algorithm a;</span><br><span class="line">    a.<span class="built_in">quickSort</span>(arr);</span><br><span class="line">    <span class="built_in">show</span>(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="image-20221005174442032.png" alt="image-20221005174442032"></p>
<h4 id="3-5快排的空间复杂度分析"><a href="#3-5快排的空间复杂度分析" class="headerlink" title="3.5快排的空间复杂度分析"></a>3.5快排的空间复杂度分析</h4><p>快排空间复杂度O(logN)，最差情况是O(N)。</p>
<p>影响空间复杂度的因素就是每次划分值的位置。快排需要调用系统栈记录划分值所在的位置，如果每次选取的划分值都在两端，则栈有N层，空间复杂度就是O(N)；都在中间，则栈有logN层，空间复杂度为O(logN)。而通过随机选取划分值是随机的，每个位置被选为划分值的可能性是相同的，因此可以使得空间复杂度保持为O(logN)。</p>
<h2 id="三、详解桶排序以及排序内容大总结"><a href="#三、详解桶排序以及排序内容大总结" class="headerlink" title="三、详解桶排序以及排序内容大总结"></a>三、详解桶排序以及排序内容大总结</h2><h3 id="1-堆–-gt-堆排序"><a href="#1-堆–-gt-堆排序" class="headerlink" title="1.堆–&gt;堆排序"></a>1.堆–&gt;堆排序</h3><p>堆插入 heapInsert：将插入的节点(index)与其父结点(index-1)&#x2F;2作比较，当比其父结点大时，交换两者位置，并与交换位置后的新父结点作比较。(即index&#x3D;(index-1)&#x2F;2)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (arr[index] &gt; arr[(index - <span class="number">1</span>) / <span class="number">2</span>]) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[index], arr[(index - <span class="number">1</span>) / <span class="number">2</span>]);</span><br><span class="line">        index = (index - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>堆化 heapify:   用一个变量存储根节点（最大值），然后将最后一个节点的值移到根节点，heapSize–（等同于将最后一个节点剔除出堆）。这时整个完全二叉树可能不是堆，需要从头节点开始，选择左孩子和右孩子中的最大值，如果比最大值小，则与这个孩子交换，直到比当前位置的左孩子右孩子的值都大，或者当前位置没有左孩子（当然也不可能有右孩子）。时间复杂度为O(logN)，向上走一个高度。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapify</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> index, <span class="type">int</span> heapSize)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> l_child = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (l_child &lt; heapSize) &#123;</span><br><span class="line">        <span class="type">int</span> max = (l_child + <span class="number">1</span> &lt; heapSize) &amp;&amp; (arr[l_child + <span class="number">1</span>] &gt; arr[l_child]) ? l_child + <span class="number">1</span> : l_child;</span><br><span class="line">        max = arr[index] &lt; arr[max] ? max : index;</span><br><span class="line">        <span class="keyword">if</span> (max == index) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">swap</span>(arr[max], arr[index]);</span><br><span class="line">        <span class="comment">//next loop</span></span><br><span class="line">        index = max;</span><br><span class="line">        l_child = <span class="number">2</span> * index + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>堆排序 heapSort:  heapSize&#x3D;0开始，每次将堆的范围扩大1，相当于每次heapInsert一个元素，最后将整个数组变成一个堆；然后将堆中的最后一个元素与第一个元素（最大值）交换，并将heapSize–（也就是将最后一个元素与堆断开联系，该值已经来到排好序的位置）；从根节点做heapify，再次调整成大根堆；继续上述过程，直到heapSize&#x3D;&#x3D;1。</p>
<ol>
<li>heapInsert：从上到下，当插入节点有父结点时，进行判定是否交换；heapify：从下到上，当索引值对应位置有左右节点时，进行判定是否交换。</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">    <span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.<span class="built_in">size</span>() &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//堆插入和堆化都可以实现建堆操作</span></span><br><span class="line"><span class="comment">//        for (int i = 0; i &lt; arr.size(); i++) &#123;//O(N)</span></span><br><span class="line"><span class="comment">//            heapInsert(arr, i);//O(logN)</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = arr.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="built_in">heapify</span>(arr, i, arr.<span class="built_in">size</span>());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> heapSize = arr.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//最后一个节点与根节点进行交换</span></span><br><span class="line">        <span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[--heapSize]);</span><br><span class="line">        <span class="keyword">while</span> (heapSize &gt; <span class="number">0</span>) &#123;<span class="comment">//O(N)</span></span><br><span class="line">            <span class="comment">//不断堆化并交换最后节点和根节点</span></span><br><span class="line">            <span class="built_in">heapify</span>(arr, <span class="number">0</span>, heapSize);<span class="comment">//O(logN)</span></span><br><span class="line">            <span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[--heapSize]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++,数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title>全国大学生数学竞赛笔记</title>
    <url>/2022/09/22/CMC/</url>
    <content><![CDATA[<h1 id="全国大学生数学竞赛（100分）"><a href="#全国大学生数学竞赛（100分）" class="headerlink" title="全国大学生数学竞赛（100分）"></a>全国大学生数学竞赛（100分）</h1><h1 id="12届初赛"><a href="#12届初赛" class="headerlink" title="12届初赛"></a>12届初赛</h1><h2 id="a-填空题-30分，6分-x2F-个"><a href="#a-填空题-30分，6分-x2F-个" class="headerlink" title="a. 填空题	(30分，6分&#x2F;个)"></a>a. 填空题	<strong>(30分，6分&#x2F;个)</strong></h2><h3 id="1-1-洛必达，等价无穷小"><a href="#1-1-洛必达，等价无穷小" class="headerlink" title="1.1 洛必达，等价无穷小"></a>1.1 洛必达，等价无穷小</h3><p>![image-20220922211204527](Mathematical Competition&#x2F;image-20220922211204527.png)</p>
<p>![775C5845FC1A5CFC5C435AA696082C2A](Mathematical Competition&#x2F;775C5845FC1A5CFC5C435AA696082C2A.jpg)</p>
<h3 id="1-2-莱布尼茨"><a href="#1-2-莱布尼茨" class="headerlink" title="1.2 莱布尼茨"></a>1.2 莱布尼茨</h3><p>![image-20220922211453797](Mathematical Competition&#x2F;image-20220922211453797.png)</p>
<p>![194263B157565761F235842A8A2E954A](Mathematical Competition&#x2F;194263B157565761F235842A8A2E954A.jpg)</p>
<h3 id="1-3-隐函数求导"><a href="#1-3-隐函数求导" class="headerlink" title="1.3 隐函数求导"></a>1.3 隐函数求导</h3><p>![image-20220922211505723](Mathematical Competition&#x2F;image-20220922211505723.png)</p>
<p>![3708996950FAE7F370A5E25C95AB252F](Mathematical Competition&#x2F;3708996950FAE7F370A5E25C95AB252F.jpg)</p>
<h3 id="1-4-广义二重积分"><a href="#1-4-广义二重积分" class="headerlink" title="1.4 广义二重积分"></a>1.4 广义二重积分</h3><p>![image-20220922211525820](Mathematical Competition&#x2F;image-20220922211525820.png)</p>
<p>![08ABF97E5113C32245045EEE737FBB19](Mathematical Competition&#x2F;08ABF97E5113C32245045EEE737FBB19.jpg)</p>
<h3 id="1-5-构造凑数，等价无穷小"><a href="#1-5-构造凑数，等价无穷小" class="headerlink" title="1.5 构造凑数，等价无穷小"></a>1.5 构造凑数，等价无穷小</h3><p>![image-20220922211541772](Mathematical Competition&#x2F;image-20220922211541772.png)</p>
<p>![18E3EBF9C37CFD65508A742C5BE33EBC](Mathematical Competition&#x2F;18E3EBF9C37CFD65508A742C5BE33EBC.jpg)</p>
<h2 id="b-解答题"><a href="#b-解答题" class="headerlink" title="b. 解答题"></a>b. 解答题</h2><h3 id="2-1-数列极限，幂级数展开式（10分）-image-20220923101826784-Mathematical-Competition-x2F-image-20220923101826784-png"><a href="#2-1-数列极限，幂级数展开式（10分）-image-20220923101826784-Mathematical-Competition-x2F-image-20220923101826784-png" class="headerlink" title="2.1 数列极限，幂级数展开式（10分）![image-20220923101826784](Mathematical Competition&#x2F;image-20220923101826784.png)"></a>2.1 数列极限，幂级数展开式（10分）![image-20220923101826784](Mathematical Competition&#x2F;image-20220923101826784.png)</h3><p><strong>NOTE:</strong></p>
<p>​	1.要让分母尽可能的小，简单，分子无所谓。</p>
<p>​	2.找到规律就进行递归推导，得出一个通项</p>
<p>​	3.要联想到并灵活运用幂级数展开式</p>
<p><img src="IMG_20220927_085116.jpg" alt="IMG_20220927_085116"></p>
<h3 id="2-2-零点定理-x2F-介值定理，拉格朗日中值定理（10分）-image-20220923110446794-Mathematical-Competition-x2F-image-20220923110446794-png"><a href="#2-2-零点定理-x2F-介值定理，拉格朗日中值定理（10分）-image-20220923110446794-Mathematical-Competition-x2F-image-20220923110446794-png" class="headerlink" title="2.2 零点定理&#x2F;介值定理，拉格朗日中值定理（10分）![image-20220923110446794](Mathematical Competition&#x2F;image-20220923110446794.png)"></a>2.2 零点定理&#x2F;介值定理，拉格朗日中值定理（10分）![image-20220923110446794](Mathematical Competition&#x2F;image-20220923110446794.png)</h3><p><strong>NOTE:</strong></p>
<p>​	1.根据题目获取有效信息，因为f(0)!&#x3D;f(1)，不满足罗尔中值定理的条件。</p>
<p>​	2.学会转换思路，作辅助函数F(x0)&#x3D;f(x0)-2+3x0，然后利用闭区间连续函数的零点定理或介值定理求解。</p>
<p>​	3.由于第一问已经排除掉使用罗尔中值定理的可能，而柯西中值定理又涉及f(x),g(x)两个函数，因此在第二问应该联想到拉格朗日中值定理，通过x0划分区间即可证明结论，又能保证所给两个参数不相等。</p>
<p><img src="IMG_20220927_085120.jpg" alt="IMG_20220927_085120"></p>
<p><img src="IMG_20220927_085131.jpg" alt="IMG_20220927_085131"></p>
<h3 id="2-3-微分，代换法，根据二阶导求一阶导和原函数（12分）-image-20220923215352878-Mathematical-Competition-x2F-image-20220923215352878-png"><a href="#2-3-微分，代换法，根据二阶导求一阶导和原函数（12分）-image-20220923215352878-Mathematical-Competition-x2F-image-20220923215352878-png" class="headerlink" title="2.3 微分，代换法，根据二阶导求一阶导和原函数（12分）![image-20220923215352878](Mathematical Competition&#x2F;image-20220923215352878.png)"></a>2.3 微分，代换法，根据二阶导求一阶导和原函数（12分）![image-20220923215352878](Mathematical Competition&#x2F;image-20220923215352878.png)</h3><p><img src="IMG_20220927_085143.jpg" alt="IMG_20220927_085143"></p>
<p><img src="IMG_20220927_085149.jpg" alt="IMG_20220927_085149"></p>
<h3 id="2-4-（12分）-image-20220924105917018-Mathematical-Competition-x2F-image-20220924105917018-png"><a href="#2-4-（12分）-image-20220924105917018-Mathematical-Competition-x2F-image-20220924105917018-png" class="headerlink" title="2.4 （12分）![image-20220924105917018](Mathematical Competition&#x2F;image-20220924105917018.png)"></a>2.4 （12分）![image-20220924105917018](Mathematical Competition&#x2F;image-20220924105917018.png)</h3><h3 id="2-5-（12分）-image-20220924111518318-Mathematical-Competition-x2F-image-20220924111518318-png"><a href="#2-5-（12分）-image-20220924111518318-Mathematical-Competition-x2F-image-20220924111518318-png" class="headerlink" title="2.5 （12分）![image-20220924111518318](Mathematical Competition&#x2F;image-20220924111518318.png)"></a>2.5 （12分）![image-20220924111518318](Mathematical Competition&#x2F;image-20220924111518318.png)</h3><h3 id="2-6（14分）"><a href="#2-6（14分）" class="headerlink" title="2.6（14分）"></a>2.6（14分）</h3><h1 id="竞赛每日一题总结"><a href="#竞赛每日一题总结" class="headerlink" title="竞赛每日一题总结"></a>竞赛每日一题总结</h1><h2 id="一、微分-x2F-积分中值定理-牛顿-莱布尼茨公式"><a href="#一、微分-x2F-积分中值定理-牛顿-莱布尼茨公式" class="headerlink" title="一、微分&#x2F;积分中值定理+牛顿-莱布尼茨公式"></a>一、微分&#x2F;积分中值定理+牛顿-莱布尼茨公式</h2><p> <strong>1. 积分中值+莱布尼茨公式放缩技巧题</strong></p>
<p> <strong>2. 拉中+牛顿——莱布尼兹公式相关的不等式</strong></p>
<p><strong>10.技巧型积分放缩题【见识，积累】</strong></p>
<p>思路：</p>
<p>1.先去绝对值，变不等号为等号，再进行分析</p>
<p>2.找出不同项，利用中值定理将其变为同类项，积分第一中值定理可变f(x)，拉格朗日中值定理可变f’(x)。</p>
<p>3.变化后，利用牛顿莱布尼兹公式的逆用得到一个等式，移项再加绝对值，放缩法变为所证。</p>
<p>4.难点在于第二项的变形，可以划分积分区间，去掉恒&gt;0的项，使用积中和拉中结合，配合放缩区间、绝对值不等式</p>
<p>变化。</p>
<h2 id="二、级数"><a href="#二、级数" class="headerlink" title="二、级数"></a>二、级数</h2><p><strong>3. 级数+拉格朗日中值定理</strong></p>
<p><strong>4. 级数敛散性判断与求和</strong></p>
<p><strong>5. 级数敛散性判断题【压轴题难度】</strong></p>
<p><strong>6. 4题的母题、5题放缩变换目标</strong></p>
<h2 id="三、定积分"><a href="#三、定积分" class="headerlink" title="三、定积分"></a>三、定积分</h2><p><strong>7. 夹逼准则与定积分几何定义</strong></p>
<p>8 .<strong>定积分几何意义及其应用【挖根讲透】</strong></p>
]]></content>
      <categories>
        <category>数学</category>
      </categories>
      <tags>
        <tag>高等数学</tag>
      </tags>
  </entry>
  <entry>
    <title>Python爬虫教程</title>
    <url>/2022/10/07/Python%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<h1 id="Python爬虫"><a href="#Python爬虫" class="headerlink" title="Python爬虫"></a>Python爬虫</h1><h1 id="一、第一个Python爬虫程序-获取网页html信息"><a href="#一、第一个Python爬虫程序-获取网页html信息" class="headerlink" title="一、第一个Python爬虫程序-获取网页html信息"></a>一、第一个Python爬虫程序-获取网页html信息</h1><h2 id="1-获取响应对象"><a href="#1-获取响应对象" class="headerlink" title="1) 获取响应对象"></a>1) 获取响应对象</h2><p>向百度（<a href="http://www.baidu.com/%EF%BC%89%E5%8F%91%E8%B5%B7%E8%AF%B7%E6%B1%82%EF%BC%8C%E8%8E%B7%E5%8F%96%E7%99%BE%E5%BA%A6%E9%A6%96%E9%A1%B5%E7%9A%84">http://www.baidu.com/）发起请求，获取百度首页的</a> HTML 信息，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#导包,发起请求使用urllib库的request请求模块</span></span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="comment"># urlopen()向URL发请求,返回响应对象,注意url必须完整response=urllib.request.urlopen(&#x27;http://www.baidu.com/&#x27;)</span></span><br><span class="line"><span class="built_in">print</span>(response)</span><br></pre></td></tr></table></figure>

<p>上述代码会返回百度首页的响应对象， 其中 urlopen() 表示打开一个网页地址。注意：请求的 url 必须带有 http 或者 https 传输协议。</p>
<p>输出结果，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;http.client.HTTPResponse <span class="built_in">object</span> at <span class="number">0x032F0F90</span>&gt;</span><br></pre></td></tr></table></figure>

<p>上述代码也有另外一种导包方式，也就是使用 from，代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#发起请求使用urllib库的request请求模块</span></span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> requestresponse=request.urlopen(<span class="string">&#x27;http://www.baidu.com/&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(response)</span><br></pre></td></tr></table></figure>

<h2 id="2-输出HTML信息"><a href="#2-输出HTML信息" class="headerlink" title="2) 输出HTML信息"></a>2) 输出HTML信息</h2><p>在上述代码的基础上继续编写如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#提取响应内容</span></span><br><span class="line">html = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="comment">#打印响应内容</span></span><br><span class="line"><span class="built_in">print</span>(html)</span><br></pre></td></tr></table></figure>

<p>输出结果如下，由于篇幅过长，此处只做了简单显示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt; &lt;html&gt;&lt;head&gt;&lt;meta http-equiv=<span class="string">&quot;Content-Type&quot;</span> content=<span class="string">&quot;text/html;charset=utf-8&quot;</span>&gt;&lt;meta http-equiv=<span class="string">&quot;X-UA-Compatible&quot;</span> content=<span class="string">&quot;IE=edge,chrome=1&quot;</span>&gt;&lt;meta content=<span class="string">&quot;always&quot;</span> name=<span class="string">&quot;referrer&quot;</span>&gt;&lt;meta name=<span class="string">&quot;theme-color&quot;</span> content=<span class="string">&quot;#2932e1&quot;</span>&gt;&lt;meta name=<span class="string">&quot;description&quot;</span> content=<span class="string">&quot;全球最大的中文搜索引擎、致力于让网民更便捷地获取信息，找到...&quot;</span>&gt;...&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>通过调用 response 响应对象的 read() 方法提取 HTML 信息，该方法返回的结果是字节串类型(bytes)，因此需要使用 decode() 转换为字符串。程序完整的代码程序如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="comment"># urlopen()向URL发请求,返回响应对象</span></span><br><span class="line">response=urllib.request.urlopen(<span class="string">&#x27;http://www.baidu.com/&#x27;</span>)</span><br><span class="line"><span class="comment"># 提取响应内容</span></span><br><span class="line">html = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="comment"># 打印响应内容</span></span><br><span class="line"><span class="built_in">print</span>(html)</span><br></pre></td></tr></table></figure>

<p>通过上述代码获取了百度首页的 html 信息，这是最简单、最初级的爬虫程序。后续我们还学习如何分析网页结构、解析网页数据，以及存储数据等。</p>
<h2 id="3-常用方法"><a href="#3-常用方法" class="headerlink" title="3) 常用方法"></a>3) 常用方法</h2><p>在本节您认识了第一个爬虫库 urllib，下面关于 urllib 做简单总结。</p>
<h4 id="1-urlopen"><a href="#1-urlopen" class="headerlink" title="1) urlopen()"></a>1) urlopen()</h4><p>表示向网站发起请求并获取响应对象，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">urllib.request.urlopen(url,timeout)</span><br></pre></td></tr></table></figure>

<p>urlopen() 有两个参数，说明如下：</p>
<ul>
<li>url：表示要爬取数据的 url 地址。</li>
<li>timeout：设置等待超时时间，指定时间内未得到响应则抛出超时异常。</li>
</ul>
<h4 id="2-Request"><a href="#2-Request" class="headerlink" title="2) Request()"></a>2) Request()</h4><p>该方法用于创建请求对象、包装请求头，比如重构 User-Agent（即用户代理，指用户使用的浏览器）使程序更像人类的请求，而非机器。重构 User-Agent 是爬虫和反爬虫斗争的第一步。在下一节会做详细介绍。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">urllib.request.Request(url,headers)</span><br></pre></td></tr></table></figure>

<p>参数说明如下：</p>
<ul>
<li>url：请求的URL地址。</li>
<li>headers：重构请求头。</li>
</ul>
<h4 id="3-html响应对象方法"><a href="#3-html响应对象方法" class="headerlink" title="3) html响应对象方法"></a>3) html响应对象方法</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="built_in">bytes</span> = response.read() <span class="comment"># read()返回结果为 bytes 数据类型</span></span><br><span class="line">string = response.read().decode() <span class="comment"># decode()将字节串转换为 string 类型</span></span><br><span class="line">url = response.geturl() <span class="comment"># 返回响应对象的URL地址</span></span><br><span class="line">code = response.getcode() <span class="comment"># 返回请求时的HTTP响应码</span></span><br></pre></td></tr></table></figure>

<h4 id="4-编码解码操作"><a href="#4-编码解码操作" class="headerlink" title="4) 编码解码操作"></a>4) 编码解码操作</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#字符串转换为字节码	encode---编码</span></span><br><span class="line">string.encode(<span class="string">&quot;utf-8&quot;</span>) </span><br><span class="line"><span class="comment">#字节码转换为字符串	decode---解码</span></span><br><span class="line"><span class="built_in">bytes</span>.decode(<span class="string">&quot;utf-8&quot;</span>) </span><br></pre></td></tr></table></figure>

<h1 id="二、User-Agent（用户代理）"><a href="#二、User-Agent（用户代理）" class="headerlink" title="二、User-Agent（用户代理）"></a>二、User-Agent（用户代理）</h1><h2 id="1-爬虫程序UA信息"><a href="#1-爬虫程序UA信息" class="headerlink" title="1)爬虫程序UA信息"></a>1)爬虫程序UA信息</h2><p>下面，通过向 HTTP 测试网站（<a href="http://httpbin.org/%EF%BC%89%E5%8F%91%E9%80%81">http://httpbin.org/）发送</a> GET 请求来查看请求头信息，从而获取爬虫程序的 UA。代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入模块</span></span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://httpbin.org/get&#x27;</span></span><br><span class="line"><span class="comment"># 1、创建请求对象，包装ua信息</span></span><br><span class="line">req = urllib.request.Request(url=url)</span><br><span class="line"><span class="comment"># 向网站发送get请求</span></span><br><span class="line">response = urllib.request.urlopen(req)</span><br><span class="line"><span class="comment"># 3、提取响应内容</span></span><br><span class="line">html = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(html)</span><br></pre></td></tr></table></figure>

<p>程序运行后，输出的请求头信息如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">F:\PyCharmProjects\venv\Scripts\python.exe F:/PyCharmProjects/Practise_Example/test.py</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;args&quot;</span>: &#123;&#125;, </span><br><span class="line">  <span class="string">&quot;headers&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;Accept-Encoding&quot;</span>: <span class="string">&quot;identity&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Host&quot;</span>: <span class="string">&quot;httpbin.org&quot;</span>, </span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Python-urllib/3.9&quot;</span>, </span><br><span class="line">    <span class="string">&quot;X-Amzn-Trace-Id&quot;</span>: <span class="string">&quot;Root=1-633ed52a-287adc06553c454d579de238&quot;</span></span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="string">&quot;origin&quot;</span>: <span class="string">&quot;183.200.174.154&quot;</span>, </span><br><span class="line">  <span class="string">&quot;url&quot;</span>: <span class="string">&quot;http://httpbin.org/get&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从输出结果可以看出，User-Agent 竟然是 Python-urllib&#x2F;3.9，这显然是爬虫程序访问网站。因此就需要重构 User-Agent，将其伪装成“浏览器”访问网站。</p>
<p>注意：<a href="http://httpbin.org/">httpbin.org </a>这个网站能测试 HTTP 请求和响应的各种信息，比如 cookie、IP、headers 和登录验证等，且支持 GET、POST 等多种方法，对 Web 开发和测试很有帮助。</p>
<h2 id="2-重构爬虫UA信息"><a href="#2-重构爬虫UA信息" class="headerlink" title="2)重构爬虫UA信息"></a>2)重构爬虫UA信息</h2><p>通过<a href="https://useragent.buyaocha.com/">在线识别工具</a>，可以查看本机的浏览器版本以及 UA 信息</p>
<p>下面使用<code>urllib.request.Request()</code>方法重构 User-Agent 信息，代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入模块</span></span><br><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重构请求头，伪装成 Mac火狐浏览器访问，可以使用上表中任意浏览器的UA信息</span></span><br><span class="line">my_headers = &#123;</span><br><span class="line">    <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.12; rv:65.0) Gecko/20100101 Firefox/65.0&#x27;</span>&#125;</span><br><span class="line">url = <span class="string">&#x27;http://httpbin.org/get&#x27;</span></span><br><span class="line"><span class="comment"># 1、创建请求对象，包装ua信息</span></span><br><span class="line">req = urllib.request.Request(url=url, headers=my_headers)</span><br><span class="line"><span class="comment"># 2、向网站发送get请求</span></span><br><span class="line">response = urllib.request.urlopen(req)</span><br><span class="line"><span class="comment"># 3、提取响应内容</span></span><br><span class="line">html = response.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(html)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>程序的运行结果，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">F:\PyCharmProjects\venv\Scripts\python.exe F:/PyCharmProjects/Practise_Example/test.py</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;args&quot;</span>: &#123;&#125;, </span><br><span class="line">  <span class="string">&quot;headers&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;Accept-Encoding&quot;</span>: <span class="string">&quot;identity&quot;</span>, </span><br><span class="line">    <span class="string">&quot;Host&quot;</span>: <span class="string">&quot;httpbin.org&quot;</span>, </span><br><span class="line">    <span class="string">&quot;User-Agent&quot;</span>: <span class="string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10.12; rv:65.0) Gecko/20100101 Firefox/65.0&quot;</span>, </span><br><span class="line">    <span class="string">&quot;X-Amzn-Trace-Id&quot;</span>: <span class="string">&quot;Root=1-633ed58d-6a4ab11747ed04a10e28b758&quot;</span></span><br><span class="line">  &#125;, </span><br><span class="line">  <span class="string">&quot;origin&quot;</span>: <span class="string">&quot;183.200.174.154&quot;</span>, </span><br><span class="line">  <span class="string">&quot;url&quot;</span>: <span class="string">&quot;http://httpbin.org/get&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上述代码重构了 User-Agent 字符串信息，这样就解决了网站通过识别 User-Agent 来封杀爬虫程序的问题。当然这只是应对反爬策略的第一步。重构 UA 也可以通过其他模块实现，比如 requests 模块。</p>
<h1 id="三、构建User-Agnet代理池"><a href="#三、构建User-Agnet代理池" class="headerlink" title="三、构建User-Agnet代理池"></a>三、构建User-Agnet代理池</h1><p>在编写爬虫程序时，一般都会构建一个 User-Agent （用户代理）池，就是把多个浏览器的 UA 信息放进列表中，然后再从中随机选择。构建用户代理池，能够避免总是使用一个 UA 来访问网站，因为短时间内总使用一个 UA 高频率访问的网站，可能会引起网站的警觉，从而封杀掉 IP。</p>
<h2 id="1-自定义UA代理池"><a href="#1-自定义UA代理池" class="headerlink" title="1)自定义UA代理池"></a>1)自定义UA代理池</h2><p>构建代理池的方法也非常简单，在您的 Pycharm 工作目录中定义一个 ua_info.py 文件，并将以下 UA 信息以列表的形式粘贴到该文件中，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ua_list = [</span><br><span class="line">    <span class="string">&#x27;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Maxthon 2.0&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_0) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;User-Agent:Opera/9.80 (Windows NT 6.1; U; en) Presto/2.8.131 Version/11.11&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Mozilla/5.0 (Windows NT 6.1; rv:2.0.1) Gecko/20100101 Firefox/4.0.1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0)&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Mozilla/5.0 (Windows; U; Windows NT 6.1; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27; Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27; Mozilla/5.0 (Macintosh; Intel Mac OS X 10.6; rv:2.0.1) Gecko/20100101 Firefox/4.0.1&#x27;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>经过上述操作，用户代理池就构建成功。</p>
<h2 id="2-模块随机获取UA"><a href="#2-模块随机获取UA" class="headerlink" title="2)模块随机获取UA"></a>2)模块随机获取UA</h2><p>您也可以使用专门第三方的模块来随机获取浏览器 UA 信息，不过该模块需要单独安装，安装方式如下：</p>
<p>pip install fake-useragent</p>
<p>下载安装成功后，演示如下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> fake_useragent <span class="keyword">import</span> UserAgent</span><br><span class="line"></span><br><span class="line">ua = UserAgent()</span><br><span class="line"><span class="built_in">print</span>(ua.ie)</span><br><span class="line"><span class="built_in">print</span>(ua.ie)</span><br><span class="line"><span class="built_in">print</span>(ua.chrome)</span><br><span class="line"><span class="built_in">print</span>(ua.chrome)</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#随机获取ie的ua信息</span></span><br><span class="line">Mozilla/<span class="number">5.0</span> (compatible; MSIE <span class="number">8.0</span>; Windows NT <span class="number">5.1</span>; Trident/<span class="number">4.0</span>; InfoPath<span class="number">.2</span>; SLCC1; .NET CLR <span class="number">3.0</span><span class="number">.4506</span><span class="number">.2152</span>; .NET CLR <span class="number">3.5</span><span class="number">.30729</span>; .NET CLR <span class="number">2.0</span><span class="number">.50727</span>)</span><br><span class="line">Mozilla/<span class="number">5.0</span> (compatible; MSIE <span class="number">10.0</span>; Windows NT <span class="number">6.1</span>; Trident/<span class="number">5.0</span>)</span><br><span class="line"><span class="comment">#随机获取火狐的ua信息</span></span><br><span class="line">Mozilla/<span class="number">5.0</span> (Windows NT <span class="number">4.0</span>; WOW64) AppleWebKit/<span class="number">537.36</span> (KHTML, like Gecko) Chrome/<span class="number">37.0</span><span class="number">.2049</span><span class="number">.0</span> Safari/<span class="number">537.36</span></span><br><span class="line">Mozilla/<span class="number">5.0</span> (Windows NT <span class="number">6.2</span>; WOW64) AppleWebKit/<span class="number">537.36</span> (KHTML, like Gecko) Chrome/<span class="number">29.0</span><span class="number">.1547</span><span class="number">.2</span> Safari/<span class="number">537.36</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="3-URL编码-x2F-解码详解"><a href="#3-URL编码-x2F-解码详解" class="headerlink" title="3)URL编码&#x2F;解码详解"></a>3)URL编码&#x2F;解码详解</h2><p>当 URL 路径或者查询参数中，带有中文或者特殊字符的时候，就需要对 URL 进行编码（采用十六进制编码格式）。URL 编码的原则是使用安全字符去表示那些不安全的字符。</p>
<p>安全字符，指的是没有特殊用途或者特殊意义的字符。</p>
<h3 id="3-1-URL基本组成"><a href="#3-1-URL基本组成" class="headerlink" title="3.1 URL基本组成"></a>3.1 URL基本组成</h3><p>URL 是由一些简单的组件构成，比如协议、域名、端口号、路径和查询字符串等，示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">http://www.biancheng.net/index?param=<span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>路径和查询字符串之间使用问号<code>?</code>隔开。上述示例的域名为 <a href="http://www.biancheng.net,路径为/">www.biancheng.net，路径为</a> index，查询字符串为 param&#x3D;1。</p>
<p>URL 中规定了一些具有特殊意义的字符，常被用来分隔两个不同的 URL 组件，这些字符被称为<strong>保留字符</strong>。例如：</p>
<ul>
<li>冒号：用于分隔协议和主机组件，斜杠用于分隔主机和路径</li>
<li><code>?</code>：用于分隔路径和查询参数等。</li>
<li><code>=</code>用于表示查询参数中的键值对。</li>
<li><code>&amp;</code>符号用于分隔查询多个键值对。</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">其余常用的保留字符有：/ . ... <span class="comment"># @ $ + ; %</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-哪些字符需要编码"><a href="#3-2-哪些字符需要编码" class="headerlink" title="3.2 哪些字符需要编码"></a>3.2 哪些字符需要编码</h3><p>URL 之所以需要编码，是因为 URL 中的某些字符会引起歧义，比如 URL 查询参数中包含了”&amp;”或者”%”就会造成服务器解析错误；再比如，URL 的编码格式采用的是 ASCII 码而非 Unicode 格式，这表明 URL 中不允许包含任何非 ASCII 字符（比如中文），否则就会造成 URL 解析错误。</p>
<p>URL 编码协议规定（RFC3986 协议）：URL 中只允许使用 ASCII 字符集可以显示的字符，比如英文字母、数字、和<code>- _ . ~ ! *</code>这 6 个<strong>特殊字符</strong>。当在 URL 中使用不属于 ASCII 字符集的字符时，就要使用特殊的符号对该字符进行编码，比如空格需要用<code>%20</code>来表示。</p>
<p>除了无法显示的字符需要编码外，还需要对 URL 中的部分<strong>保留字符</strong>和<strong>不安全字符</strong>进行编码。下面列举了部分不安全字符：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">[ ] &lt; &gt; <span class="string">&quot; &quot;</span>  &#123; &#125; | \ ^ * · ‘ ’ 等</span><br></pre></td></tr></table></figure>

<p>下面示例，查询字符串中包含一些特殊字符，这些特殊字符不需要编码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">http://www.biancheng.net/index?param=<span class="number">10</span>!*&amp;param1=<span class="number">20</span>!-~_</span><br></pre></td></tr></table></figure>

<p>下表对 URL 中部分保留字符和不安全字符进行了说明：</p>
<p><img src="image-20221006220332348.png" alt="image-20221006220332348"></p>
<p>下面简单总结一下，哪些字符需要编码，分为以下三种情况：</p>
<ul>
<li>ASCII 表中没有对应的可显示字符，例如，汉字。</li>
<li>不安全字符，包括：# ”% &lt;&gt; [] {} | \ ^ &#96; 。</li>
<li>部分保留字符，即 &amp; &#x2F; : ; &#x3D; ? @ 。</li>
</ul>
<h3 id="3-3-Python实现编码与解码"><a href="#3-3-Python实现编码与解码" class="headerlink" title="3.3 Python实现编码与解码"></a>3.3 Python实现编码与解码</h3><p>Python 的标准库<code>urllib.parse</code>模块中提供了用来编码和解码的方法，分别是 urlencode() 与 unquote() 方法。</p>
<p><img src="image-20221006220548511.png" alt="image-20221006220548511"></p>
<h4 id="1-编码urlencode"><a href="#1-编码urlencode" class="headerlink" title="1) 编码urlencode()"></a>1) 编码urlencode()</h4><p>下面以百度搜索为例进行讲解。首先打开百度首页，在搜索框中输入“爬虫”，然后点击“百度一下”。当搜索结果显示后，此时地址栏的 URL 信息，如下所示：</p>
<p><strong>注：</strong>1.<strong>%E7%88%AC%E8%99%AB</strong>&lt;&#x3D;&gt;<strong>爬虫</strong> 	2.<strong>word</strong>&lt;&#x3D;&gt;<strong>wd</strong></p>
<p><a href="https://www.baidu.com/s?word=%E7%88%AC%E8%99%AB&amp;tn=68018901_10_oem_dg">https://www.baidu.com/s?word=%E7%88%AC%E8%99%AB&amp;tn=68018901_10_oem_dg</a></p>
<p>第一个查询字符串就是“wd&#x3D;爬虫”，其中 wd 表示查询字符串的键，而“爬虫”则代表您输入的值。</p>
<p>在网页地址栏中删除多余的查询字符串，最后显示的 URL 如下所示：</p>
<p><a href="https://www.baidu.com/s?word=%E7%88%AC%E8%99%AB">https://www.baidu.com/s?word=爬虫</a></p>
<p>使用搜索修改后的 URL 进行搜索，依然会得到相同页面。因此可知“wd”参数是百度搜索的关键查询参数。下面编写爬虫程序对 “wd&#x3D;爬虫”进行编码，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 导入parse模块</span></span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建查询字符串字典</span></span><br><span class="line">query_string = &#123;<span class="string">&#x27;wd&#x27;</span>: <span class="string">&#x27;爬虫&#x27;</span>&#125;</span><br><span class="line"><span class="comment"># 调用parse模块的urlencode()进行编码</span></span><br><span class="line">result = parse.urlencode(query_string)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="comment"># 使用format函数格式化字符串，拼接url地址</span></span><br><span class="line">url = <span class="string">&#x27;http://www.baidu.com/s?&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(result)</span><br><span class="line"><span class="built_in">print</span>(url)</span><br></pre></td></tr></table></figure>

<p>输出结果，如下所示：</p>
<p>​	wd&#x3D;%E7%88%AC%E8%99%AB<br>​        	<a href="http://www.baidu.com/s?wd=%E7%88%AC%E8%99%AB">http://www.baidu.com/s?wd=%E7%88%AC%E8%99%AB</a></p>
<p>编码后的 URL 地址依然可以通过地网页址栏实现搜索功能。</p>
<p>除了使用 urlencode() 方法之外，也可以使用 quote(string) 方法实现编码，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;http://baidu.com/s?wd=&#123;&#125;&#x27;</span></span><br><span class="line">wd = <span class="built_in">input</span>(<span class="string">&#x27;please input what you want to search:\n&#x27;</span>)</span><br><span class="line">query_str = parse.quote(wd)</span><br><span class="line"><span class="built_in">print</span>(url.<span class="built_in">format</span>(query_str))</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">please <span class="built_in">input</span> what you want to search:</span><br><span class="line">Python是世界上最好的语言</span><br><span class="line">http://baidu.com/s?wd=Python%E6%<span class="number">98</span>%AF%E4%B8%<span class="number">96</span>%E7%<span class="number">95</span>%8C%E4%B8%8A%E6%9C%<span class="number">80</span>%E5%A5%BD%E7%9A%<span class="number">84</span>%E8%AF%AD%E8%A8%<span class="number">80</span></span><br></pre></td></tr></table></figure>

<p>注意：quote() 只能对字符串编码，而 urlencode() 可以直接对查询字符串字典进行编码。因此在定义 URL 时，需要注意两者之间的差异。方法如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># urllib.parse</span></span><br><span class="line">urllib.parse.urlencode(&#123;<span class="string">&#x27;key&#x27;</span>:<span class="string">&#x27;value&#x27;</span>&#125;) <span class="comment">#字典</span></span><br><span class="line">urllib.parse.quote(string) <span class="comment">#字符串</span></span><br></pre></td></tr></table></figure>

<h4 id="2-解码unquote-string"><a href="#2-解码unquote-string" class="headerlink" title="2) 解码unquote(string)"></a>2) 解码unquote(string)</h4><p>解码是对编码后的 URL 进行还原的一种操作，示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编码后的url</span></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&#x27;%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6&#x27;</span></span><br><span class="line"><span class="comment"># url再封装</span></span><br><span class="line">str2 = parse.quote(<span class="built_in">str</span>)</span><br><span class="line"><span class="comment"># url还原</span></span><br><span class="line">result = parse.unquote(<span class="built_in">str</span>)</span><br><span class="line"><span class="comment"># 封装后的url还原</span></span><br><span class="line">result2 = parse.unquote(str2)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br><span class="line"><span class="built_in">print</span>(result2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p>​	清华大学<br>​			%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6</p>
<h4 id="3-URL地址拼接方式"><a href="#3-URL地址拼接方式" class="headerlink" title="3) URL地址拼接方式"></a>3) URL地址拼接方式</h4><p>最后，给大家介绍三种拼接 URL 地址的方法。除了使用 format() 函数外，还可以使用字符串相加，以及字符串占位符，总结如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.字符串相加</span></span><br><span class="line">baseUrl = <span class="string">&#x27;http://www.baidu.com/s?&#x27;</span></span><br><span class="line">params = <span class="string">&#x27;wd=%E7%BC%96%E7%A8%8B&#x27;</span></span><br><span class="line">url = baseUrl + params</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;字符串相加：&#x27;</span> + url)</span><br><span class="line"><span class="comment"># 2.字符串格式化</span></span><br><span class="line">url1 = <span class="string">&#x27;http://www.baidu.com/s?%s&#x27;</span> % params</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;字符串格式化：&#x27;</span> + url1)</span><br><span class="line"><span class="comment"># 3.format()方法</span></span><br><span class="line">url2 = <span class="string">&#x27;http://www.baidu.com/s?&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(params)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;format()方法：&#x27;</span> + url2)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p>​	字符串相加：<a href="http://www.baidu.com/s?wd=%E7%BC%96%E7%A8%8B">http://www.baidu.com/s?wd=%E7%BC%96%E7%A8%8B</a><br>​			字符串格式化：<a href="http://www.baidu.com/s?wd=%E7%BC%96%E7%A8%8B">http://www.baidu.com/s?wd=%E7%BC%96%E7%A8%8B</a><br>​		 	format()方法：<a href="http://www.baidu.com/s?wd=%E7%BC%96%E7%A8%8B">http://www.baidu.com/s?wd=%E7%BC%96%E7%A8%8B</a></p>
<h1 id="四、【实例】Python爬虫抓取网页"><a href="#四、【实例】Python爬虫抓取网页" class="headerlink" title="四、【实例】Python爬虫抓取网页"></a>四、【实例】Python爬虫抓取网页</h1><p>本节讲解第一个 Python 爬虫实战案例：抓取您想要的网页，并将其保存至本地计算机。</p>
<p>首先我们对要编写的爬虫程序进行简单地分析，该程序可分为以下三个部分：</p>
<ul>
<li><p>拼接 url 地址</p>
</li>
<li><p>发送请求</p>
</li>
<li><p>将文件保存至本地</p>
<p>​</p>
</li>
</ul>
<p>		</p>
<p>明确逻辑后，我们就可以正式编写爬虫程序了。</p>
<h2 id="1-导入所需模块"><a href="#1-导入所需模块" class="headerlink" title="1)导入所需模块"></a>1)导入所需模块</h2><p>本节内容使用 urllib 库来编写爬虫，下面导入程序所用模块：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse</span><br></pre></td></tr></table></figure>

<h2 id="2-拼接URL地址"><a href="#2-拼接URL地址" class="headerlink" title="2)拼接URL地址"></a>2)拼接URL地址</h2><p>定义 URL 变量，拼接 url 地址。代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">url = <span class="string">&#x27;http://www.baidu.com/s?wd=&#123;&#125;&#x27;</span></span><br><span class="line"><span class="comment">#想要搜索的内容</span></span><br><span class="line">word = <span class="built_in">input</span>(<span class="string">&#x27;请输入搜索内容:&#x27;</span>)</span><br><span class="line">params = parse.quote(word)</span><br><span class="line">full_url = url.<span class="built_in">format</span>(params)</span><br></pre></td></tr></table></figure>

<h2 id="3-向URL发送请求"><a href="#3-向URL发送请求" class="headerlink" title="3)向URL发送请求"></a>3)向URL发送请求</h2><p>发送请求主要分为以下几个步骤：</p>
<ul>
<li>创建请求对象-Request</li>
<li>获取响应对象-urlopen</li>
<li>获取响应内容-read</li>
</ul>
<p>代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#重构请求头</span></span><br><span class="line">headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:6.0) Gecko/20100101 Firefox/6.0&#x27;</span>&#125;</span><br><span class="line"><span class="comment">#创建请求对应</span></span><br><span class="line">req = request.Request(url=full_url,headers=headers)</span><br><span class="line"><span class="comment">#获取响应对象</span></span><br><span class="line">res = request.urlopen(req)</span><br><span class="line"><span class="comment">#获取响应内容</span></span><br><span class="line">html = res.read().decode(<span class="string">&quot;utf-8&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="4-保存为本地文件"><a href="#4-保存为本地文件" class="headerlink" title="4)保存为本地文件"></a>4)保存为本地文件</h2><p>把爬取的照片保存至本地，此处需要使用 Python 编程的文件 IO 操作，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">filename = word + <span class="string">&#x27;.html&#x27;</span><span class="keyword">with</span> <span class="built_in">open</span>(filename,<span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:    f.write(html)</span><br></pre></td></tr></table></figure>

<p>完整程序如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request,parse</span><br><span class="line"><span class="comment"># 1.拼url地址</span></span><br><span class="line">url = <span class="string">&#x27;http://www.baidu.com/s?wd=&#123;&#125;&#x27;</span></span><br><span class="line">word = <span class="built_in">input</span>(<span class="string">&#x27;请输入搜索内容:&#x27;</span>)</span><br><span class="line">params = parse.quote(word)</span><br><span class="line">full_url = url.<span class="built_in">format</span>(params)</span><br><span class="line"><span class="comment"># 2.发请求保存到本地</span></span><br><span class="line">headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:6.0) Gecko/20100101 Firefox/6.0&#x27;</span>&#125;</span><br><span class="line">req = request.Request(url=full_url,headers=headers)</span><br><span class="line">res = request.urlopen(req)</span><br><span class="line">html = res.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="comment"># 3.保存文件至当前目录</span></span><br><span class="line">filename = word + <span class="string">&#x27;.html&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(filename,<span class="string">&#x27;w&#x27;</span>,encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(html)</span><br></pre></td></tr></table></figure>

<p>尝试运行程序，并输入编程帮，确认搜索，然后您会在 Pycharm 当前的工作目录中找到“编程帮.html”文件。</p>
<h2 id="5-函数式编程修改程序"><a href="#5-函数式编程修改程序" class="headerlink" title="5)函数式编程修改程序"></a>5)函数式编程修改程序</h2><p>Python 函数式编程可以让程序的思路更加清晰、易懂。接下来，使用函数编程的思想更改上面代码。</p>
<p>定义相应的函数，通过调用函数来执行爬虫程序。修改后的代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 拼接url</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_url</span>(<span class="params">word</span>):</span><br><span class="line">    url = <span class="string">&#x27;http://www.baidu.com/s?&#123;&#125;&#x27;</span></span><br><span class="line">    params = parse.urlencode(&#123;<span class="string">&#x27;wd&#x27;</span>: word&#125;)</span><br><span class="line">    url = url.<span class="built_in">format</span>(params)</span><br><span class="line">    <span class="keyword">return</span> url</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送请求，保存本地文件</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">request_url</span>(<span class="params">url, filename</span>):</span><br><span class="line">    <span class="comment"># 伪装头，发送请求并打开url</span></span><br><span class="line">    headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:6.0) Gecko/20100101 Firefox/6.0&#x27;</span>&#125;</span><br><span class="line">    req = request.Request(url=url, headers=headers)</span><br><span class="line">    res = request.urlopen(req)</span><br><span class="line">    html = res.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">    <span class="comment"># 保存文件</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(html)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 主程序入口</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    word = <span class="built_in">input</span>(<span class="string">&#x27;请输入搜索内容：&#x27;</span>)</span><br><span class="line">    url = get_url(word)</span><br><span class="line">    filename = word + <span class="string">&#x27;.html&#x27;</span></span><br><span class="line">    request_url(url, filename)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>除了使用函数式编程外，您也可以使用面向对象的编程方法（本教程主要以该方法），在后续内容中会做相应介绍。</p>
<h1 id="五、【实例】Python爬虫抓取百度贴吧数据"><a href="#五、【实例】Python爬虫抓取百度贴吧数据" class="headerlink" title="五、【实例】Python爬虫抓取百度贴吧数据"></a>五、【实例】Python爬虫抓取百度贴吧数据</h1><p>本节继续讲解 Python 爬虫实战案例：抓取百度贴吧（<a href="https://tieba.baidu.com/%EF%BC%89%E9%A1%B5%E9%9D%A2%EF%BC%8C%E6%AF%94%E5%A6%82">https://tieba.baidu.com/）页面，比如</a> Python爬虫吧、编程吧，只抓取贴吧的前 5 个页面即可。本节我们将使用面向对象的编程方法来编写程序。</p>
<h2 id="1-判断页面类型"><a href="#1-判断页面类型" class="headerlink" title="1)判断页面类型"></a>1)判断页面类型</h2><p>通过简单的分析可以得知，待抓取的百度贴吧页面属于静态网页，分析方法非常简单：打开百度贴吧，搜索“Python爬虫”，在出现的页面中复制任意一段信息，比如“爬虫需要 http 代理的原因”，然后点击右键选择查看源码，并使用 Ctrl+F 快捷键在源码页面搜索刚刚复制的数据，如下所示：</p>
<p><img src="9-210Q9112J2329.png" alt="img"></p>
<p>由上图可知，页面内的所有信息都包含在源码页中，数据并不需要从数据库另行加载，因此该页面属于静态页面。</p>
<h2 id="2-寻找URL变化规律"><a href="#2-寻找URL变化规律" class="headerlink" title="2)寻找URL变化规律"></a>2)寻找URL变化规律</h2><p>接下来寻找要爬取页面的 URL 规律，搜索“Python爬虫”后，此时贴吧第一页的的 url 如下所示：</p>
<p><a href="https://tieba.baidu.com/f?ie=utf-8&amp;kw=python%E7%88%AC%E8%99%AB&amp;fr=search">https://tieba.baidu.com/f?ie=utf-8&amp;kw=python爬虫&amp;fr=search</a></p>
<p>点击第二页，其 url 信息如下：</p>
<p><a href="https://tieba.baidu.com/f?kw=python%E7%88%AC%E8%99%AB&amp;ie=utf-8&amp;pn=50">https://tieba.baidu.com/f?kw=python爬虫&amp;ie=utf-8&amp;pn=50</a></p>
<p>点击第三页，url 信息如下：</p>
<p><a href="https://tieba.baidu.com/f?kw=python%E7%88%AC%E8%99%AB&amp;ie=utf-8&amp;pn=100">https://tieba.baidu.com/f?kw=python爬虫&amp;ie=utf-8&amp;pn=100</a></p>
<p>重新点击第一页，url 信息如下：</p>
<p><a href="https://tieba.baidu.com/f?kw=python%E7%88%AC%E8%99%AB&amp;ie=utf-8&amp;pn=0">https://tieba.baidu.com/f?kw=python爬虫&amp;ie=utf-8&amp;pn=0</a></p>
<p>如果还不确定，您可以继续多浏览几页。最后您发现 url 具有两个查询参数，分别是 kw 和 pn，并且 pn 参数具有规律性，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">第n页：pn=(n-<span class="number">1</span>)*<span class="number">50</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#参数params</span></span><br><span class="line">pn=(page-<span class="number">1</span>)*<span class="number">50</span></span><br><span class="line">params=&#123;</span><br><span class="line">         <span class="string">&#x27;kw&#x27;</span>:name,</span><br><span class="line">         <span class="string">&#x27;pn&#x27;</span>:<span class="built_in">str</span>(pn)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>url 地址可以简写为：</p>
<p><a href="https://tieba.baidu.com/f?kw=python%E7%88%AC%E8%99%AB&amp;pn=450">https://tieba.baidu.com/f?kw=python爬虫&amp;pn=450</a></p>
<h2 id="3-编写爬虫程序"><a href="#3-编写爬虫程序" class="headerlink" title="3)编写爬虫程序"></a>3)编写爬虫程序</h2><p><strong>UA池(ua_info.py)</strong></p>
<p>​	导入方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> ua_info <span class="keyword">import</span> ua_list </span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">ua_list = [</span><br><span class="line">    <span class="string">&#x27;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Maxthon 2.0&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_0) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;User-Agent:Opera/9.80 (Windows NT 6.1; U; en) Presto/2.8.131 Version/11.11&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Mozilla/5.0 (Windows NT 6.1; rv:2.0.1) Gecko/20100101 Firefox/4.0.1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0)&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Mozilla/5.0 (Windows; U; Windows NT 6.1; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27; Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27; Mozilla/5.0 (Macintosh; Intel Mac OS X 10.6; rv:2.0.1) Gecko/20100101 Firefox/4.0.1&#x27;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>下面以类的形式编写爬虫程序，并在类下编写不同的功能函数，代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request, parse</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">from</span> ua_info <span class="keyword">import</span> ua_list  <span class="comment"># 导入自己写好的UA池</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 爬虫类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaiDuTieBa_Spider</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment"># 初始化</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 定义成员变量url</span></span><br><span class="line">        self.url = <span class="string">&#x27;http://tieba.baidu.com/f?&#123;&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 请求</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_html</span>(<span class="params">self, url</span>):</span><br><span class="line">        <span class="comment"># 从ua池中随机选择一个ua</span></span><br><span class="line">        req = request.Request(url=url, headers=&#123;<span class="string">&#x27;User-Agent&#x27;</span>: random.choice(ua_list)&#125;)</span><br><span class="line">        res = request.urlopen(req)</span><br><span class="line">        <span class="comment"># windows会存在乱码问题，需要使用 gbk解码，并使用ignore忽略不能处理的字节</span></span><br><span class="line">        <span class="comment"># linux不会存在上述问题，可以直接使用decode(&#x27;utf-8&#x27;)解码</span></span><br><span class="line">        html = res.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> html</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 解析</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse_html</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存文件</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">save_html</span>(<span class="params">self, filename, html</span>):</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(filename, <span class="string">&#x27;w&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(html)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 入口</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        name = <span class="built_in">input</span>(<span class="string">&#x27;输入贴吧名：&#x27;</span>)</span><br><span class="line">        begin = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;输入起始页：&#x27;</span>))</span><br><span class="line">        end = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;输入结束页：&#x27;</span>))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># +1保证可以取到整数</span></span><br><span class="line">        <span class="keyword">for</span> page <span class="keyword">in</span> <span class="built_in">range</span>(begin, end + <span class="number">1</span>):</span><br><span class="line">            pn = (page - <span class="number">1</span>) * <span class="number">50</span></span><br><span class="line">            params = &#123;<span class="string">&#x27;kw&#x27;</span>: name,</span><br><span class="line">                      <span class="string">&#x27;pn&#x27;</span>: <span class="built_in">str</span>(pn)&#125;</span><br><span class="line">            <span class="comment"># 拼接url</span></span><br><span class="line">            params = parse.urlencode(params)  <span class="comment"># 将参数编码</span></span><br><span class="line">            url = self.url.<span class="built_in">format</span>(params)</span><br><span class="line">            <span class="built_in">print</span>(url)</span><br><span class="line">            <span class="comment"># 发送请求,返回html</span></span><br><span class="line">            html = self.get_html(url)</span><br><span class="line">            <span class="comment"># 定义路径</span></span><br><span class="line">            filename = <span class="string">&#x27;&#123;&#125;吧-第&#123;&#125;页.html&#x27;</span>.<span class="built_in">format</span>(name, page)</span><br><span class="line">            self.save_html(filename, html)</span><br><span class="line"></span><br><span class="line">            <span class="comment"># 提示</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;第&#123;&#125;页爬取成功！&#x27;</span>.<span class="built_in">format</span>(page))</span><br><span class="line">            <span class="comment"># 爬虫休眠</span></span><br><span class="line">            time.sleep(random.randint(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    start = time.time()</span><br><span class="line">    <span class="comment"># 实例化爬虫类的对象spider</span></span><br><span class="line">    spider = BaiDuTieBa_Spider()</span><br><span class="line">    spider.run()</span><br><span class="line">    end = time.time()</span><br><span class="line">    <span class="comment"># 获取程序执行时间</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;执行时间：&#123;:.2f&#125;&#x27;</span>.<span class="built_in">format</span>(end - start))</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>程序执行后，爬取的文件将会保存至 Pycharm 当前工作目录，输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入贴吧名：c++</span><br><span class="line">输入起始页：1</span><br><span class="line">输入结束页：1</span><br><span class="line">http://tieba.baidu.com/f?kw=c%2B%2B&amp;pn=0</span><br><span class="line">第1页爬取成功！</span><br><span class="line">执行时间：15.13</span><br></pre></td></tr></table></figure>

<p>以面向对象方法编写爬虫程序时，思路简单、逻辑清楚，非常容易理解，上述代码主要包含了四个功能函数，它们分别负责了不同的功能，总结如下：</p>
<h4 id="1-请求函数"><a href="#1-请求函数" class="headerlink" title="1) 请求函数"></a>1) 请求函数</h4><p>请求函数最终的结果是返回一个 HTML 对象，以方便后续的函数调用它。 </p>
<h4 id="2-解析函数"><a href="#2-解析函数" class="headerlink" title="2) 解析函数"></a>2) 解析函数</h4><p>解析函数用来解析 HTML 页面，常用的解析模块有正则解析模块、bs4 解析模块。通过分析页面，提取出所需的数据，在后续内容会做详细介绍。</p>
<h4 id="3-保存数据函数"><a href="#3-保存数据函数" class="headerlink" title="3) 保存数据函数"></a>3) 保存数据函数</h4><p>该函数负责将抓取下来的数据保至数据库中，比如 MySQL、MongoDB 等，或者将其保存为文件格式，比如 csv、txt、excel 等。</p>
<h4 id="4-入口函数"><a href="#4-入口函数" class="headerlink" title="4) 入口函数"></a>4) 入口函数</h4><p>入口函数充当整个爬虫程序的桥梁，通过调用不同的功能函数，实现数据的最终抓取。入口函数的主要任务是组织数据，比如要搜索的贴吧名、编码 url 参数、拼接 url 地址、定义文件保存路径。</p>
<h2 id="4-爬虫程序结构"><a href="#4-爬虫程序结构" class="headerlink" title="4)爬虫程序结构"></a>4)爬虫程序结构</h2><p>用面向对象的方法编写爬虫程序时，逻辑结构较为固定，总结如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 程序结构</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">xxxSpider</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 定义常用变量,比如url或计数变量等</span></span><br><span class="line">       </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_html</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 获取响应内容函数,使用随机User-Agent</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse_html</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 使用正则表达式来解析页面，提取数据</span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">write_html</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 将提取的数据按要求保存，csv、MySQL数据库等</span></span><br><span class="line">       </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 主函数，用来控制整体逻辑</span></span><br><span class="line">       </span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 程序开始运行时间</span></span><br><span class="line">    spider = xxxSpider()</span><br><span class="line">    spider.run()</span><br></pre></td></tr></table></figure>

<p>注意：掌握以上编程逻辑有助于您后续的学习。</p>
<h2 id="5-爬虫程序随机休眠"><a href="#5-爬虫程序随机休眠" class="headerlink" title="5)爬虫程序随机休眠"></a>5)爬虫程序随机休眠</h2><p>在入口函数代码中，包含了以下代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#每爬取一个页面随机休眠1-2秒钟的时间</span></span><br><span class="line">time.sleep(random.randint(<span class="number">1</span>,<span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<p>爬虫程序访问网站会非常快，这与正常人类的点击行为非常不符。因此，通过随机休眠可以使爬虫程序模仿成人类的样子点击网站，从而让网站不易察觉是爬虫访问网站，但这样做的代价就是影响程序的执行效率。</p>
<p>聚焦爬虫是一种执行效率较低的程序，提升其性能，是业界一直关注的问题，由此也诞生了效率较高的 Python 爬虫框架 Scrapy。</p>
<h1 id="六、正则表达式基本语法"><a href="#六、正则表达式基本语法" class="headerlink" title="六、正则表达式基本语法"></a>六、正则表达式基本语法</h1><p>正则表达式(regular expression)是一种字符串匹配模式或者规则，它可以用来检索、替换那些符合特定规则的文本。正则表达式几乎适用于所有编程语言，无论是前端语言 JavaScript，还是诸如许多后端语言，比如 Python、Java、C# 等，这些语言都提供了相应的函数、模块来支持正则表达式，比如 Python 的 re 模块就提供了正则表达式的常用方法。</p>
<p>在使用 Python 编写爬虫的过程中，re 模块通常做为一种解析方法来使用。通过审查网页元素来获取网页的大体结构，然后使用解析模块来提取你想要的网页信息，最终实现数据的抓取。本节对正则表达式基本语法做简单讲解。</p>
<p>注意：学习本节知识之前，您应该已经掌握了正则表达式的使用方法。</p>
<h2 id="1-正则表达式元字符"><a href="#1-正则表达式元字符" class="headerlink" title="1)正则表达式元字符"></a>1)正则表达式元字符</h2><p>下表列出了常用的正则表达式元字符：</p>
<h4 id="1-元字符"><a href="#1-元字符" class="headerlink" title="1) 元字符"></a>1) 元字符</h4><table>
<thead>
<tr>
<th>元字符</th>
<th align="left">匹配内容</th>
</tr>
</thead>
<tbody><tr>
<td>.</td>
<td align="left">匹配除换行符以外的任意字符</td>
</tr>
<tr>
<td>\w</td>
<td align="left">匹配所有普通字符(数字、字母或下划线)</td>
</tr>
<tr>
<td>\s</td>
<td align="left">匹配任意的空白符</td>
</tr>
<tr>
<td>\d</td>
<td align="left">匹配数字</td>
</tr>
<tr>
<td>\n</td>
<td align="left">匹配一个换行符</td>
</tr>
<tr>
<td>\t</td>
<td align="left">匹配一个制表符</td>
</tr>
<tr>
<td>\b</td>
<td align="left">匹配一个单词的结尾</td>
</tr>
<tr>
<td>^</td>
<td align="left">匹配字符串的开始位置</td>
</tr>
<tr>
<td>$</td>
<td align="left">匹配字符串的结尾位置</td>
</tr>
<tr>
<td>\W</td>
<td align="left">匹配非字母或数字或下划线</td>
</tr>
<tr>
<td>\D</td>
<td align="left">匹配非数字</td>
</tr>
<tr>
<td>\S</td>
<td align="left">匹配非空白符</td>
</tr>
<tr>
<td>a|b</td>
<td align="left">匹配字符 a 或字符 b</td>
</tr>
<tr>
<td>()</td>
<td align="left">正则表达式分组所用符号，匹配括号内的表达式，表示一个组。</td>
</tr>
<tr>
<td>[…]</td>
<td align="left">匹配字符组中的字符</td>
</tr>
<tr>
<td>[^…]</td>
<td align="left">匹配除了字符组中字符的所有字符</td>
</tr>
</tbody></table>
<h4 id="2-量词"><a href="#2-量词" class="headerlink" title="2) 量词"></a>2) 量词</h4><table>
<thead>
<tr>
<th>量词</th>
<th>用法说明</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>重复零次或者更多次</td>
</tr>
<tr>
<td>+</td>
<td>重复一次或者更多次</td>
</tr>
<tr>
<td>？</td>
<td>重复0次或者一次</td>
</tr>
<tr>
<td>{n}</td>
<td>重复n次</td>
</tr>
<tr>
<td>{n,}</td>
<td>重复n次或者更多次</td>
</tr>
<tr>
<td>{n,m}</td>
<td>重复n到m次</td>
</tr>
</tbody></table>
<h4 id="3-字符组"><a href="#3-字符组" class="headerlink" title="3) 字符组"></a>3) 字符组</h4><p>有时也会出现各种字符组成的字符组，这在正则表达式中使用<code>[]</code>表示，如下所示：</p>
<table>
<thead>
<tr>
<th>正则</th>
<th>待匹配字符</th>
<th>匹配结果</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>[0123456789]</td>
<td>8</td>
<td>True</td>
<td>在一个字符组里枚举所有字符，字符组里的任意一个字符 和”待匹配字符”相同都视为可以匹配。</td>
</tr>
<tr>
<td>[0123456789]</td>
<td>a</td>
<td>False</td>
<td>由于字符组中没有 “a” 字符，所以不能匹配。</td>
</tr>
<tr>
<td>[0-9]</td>
<td>7</td>
<td>True</td>
<td>也可以用-表示范围，[0-9] 就和 [0123456789] 是一个意思。</td>
</tr>
<tr>
<td>[a-z]</td>
<td>s</td>
<td>True</td>
<td>同样的如果要匹配所有的小写字母，直接用 [a-z] 就可以表示。</td>
</tr>
<tr>
<td>[A-Z]</td>
<td>B</td>
<td>True</td>
<td>[A-Z] 就表示所有的大写字母。</td>
</tr>
<tr>
<td>[0-9a-fA-F]</td>
<td>e</td>
<td>True</td>
<td>可以匹配数字，大小写形式的 a～f，用来验证十六进制字符。</td>
</tr>
</tbody></table>
<h2 id="2-贪婪模式非贪婪模式"><a href="#2-贪婪模式非贪婪模式" class="headerlink" title="2)贪婪模式非贪婪模式"></a>2)贪婪模式非贪婪模式</h2><p>正则表达式默认为贪婪匹配，也就是尽可能多的向后匹配字符，比如 {n,m} 表示匹配前面的内容出现 n 到 m 次（n 小于 m），在贪婪模式下，首先以匹配 m 次为目标，而在非贪婪模式是尽可能少的向后匹配内容，也就是说匹配 n 次即可。</p>
<p>贪婪模式转换为非贪婪模式的方法很简单，在元字符后添加“?”即可实现，如下所示：</p>
<table>
<thead>
<tr>
<th>元字符(贪婪模式)</th>
<th>非贪婪模式</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>*?</td>
</tr>
<tr>
<td>+</td>
<td>+？</td>
</tr>
<tr>
<td>？</td>
<td>??</td>
</tr>
<tr>
<td>{n,m}</td>
<td>{n,m}？</td>
</tr>
</tbody></table>
<h2 id="3-正则表达式转义"><a href="#3-正则表达式转义" class="headerlink" title="3)正则表达式转义"></a>3)正则表达式转义</h2><p>如果使用正则表达式匹配特殊字符时，则需要在字符前加<code>\</code>表示转意。常见的特殊字符如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">* + ? ^ $ [] () &#123;&#125; | \</span><br></pre></td></tr></table></figure>

<h1 id="七、Python-re模块用法详解"><a href="#七、Python-re模块用法详解" class="headerlink" title="七、Python re模块用法详解"></a>七、Python re模块用法详解</h1><p>在 Python 爬虫过程中，实现网页元素解析的方法有很多，正则解析只是其中之一，常见的还有 BeautifulSoup 和 lxml，它们都支持网页 HTML 元素的解析操作。本节重点讲解如何使用 re 正则解析模块实现网页信息的提取。</p>
<p>注意：在学习本节知识之前，您应该基本掌握了 Python re 模块的常用方法。</p>
<h2 id="1-re模块常用方法"><a href="#1-re模块常用方法" class="headerlink" title="1)re模块常用方法"></a>1)re模块常用方法</h2><h4 id="1-re-compile"><a href="#1-re-compile" class="headerlink" title="1) re.compile()"></a>1) re.compile()</h4><p>该方法用来<strong>生成</strong>正则表达式对象，其语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">regex=re.compile(pattern,flags=0)</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li>pattern：正则表达式对象。</li>
<li>flags：代表功能标志位，扩展正则表达式的匹配。</li>
</ul>
<h4 id="2-re-findall"><a href="#2-re-findall" class="headerlink" title="2) re.findall()"></a>2) re.findall()</h4><p>根据<strong>正则表达式匹配</strong>目标字符串内容。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">re.findall(pattern,string,flags=0)</span><br></pre></td></tr></table></figure>

<p>该函数的返回值是匹配到的内容列表，如果正则表达式有子组，则只能获取到子组对应的内容。参数说明如下：</p>
<ul>
<li>pattern：正则表达式对象。</li>
<li>string：目标字符串</li>
<li>flags：代表功能标志位，扩展正则表达式的匹配。</li>
</ul>
<h4 id="3-regex-findall"><a href="#3-regex-findall" class="headerlink" title="3) regex.findall()"></a>3) regex.findall()</h4><p>该函数根据<strong>正则表达式对象匹配</strong>目标字符串内容。其语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">regex.findall(string,pos,endpos)</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li>string 目标字符串。</li>
<li>pos 截取目标字符串的开始匹配位置。</li>
<li>endpos 截取目标字符串的结束匹配位置。</li>
</ul>
<h4 id="4-re-split"><a href="#4-re-split" class="headerlink" title="4) re.split()"></a>4) re.split()</h4><p>该函数使用正则表达式匹配内容，<strong>切割</strong>目标字符串。返回值是切割后的内容列表。参数说明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">re.split(pattern,string,flags = 0)</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li>pattern：正则表达式。</li>
<li>string：目标字符串。</li>
<li>flags：功能标志位,扩展正则表达式的匹配。</li>
</ul>
<p>\5) re.sub<br>该函数使用一个字符串<strong>替换</strong>正则表达式匹配到的内容。返回值是替换后的字符串。其语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">re.sub(pattern,replace,string,max,flags = 0)</span><br></pre></td></tr></table></figure>

<p>其参数说明：</p>
<ul>
<li>pattern：正则表达式。</li>
<li>replace：替换的字符串。</li>
<li>string：目标字符串。</li>
<li>max：最多替换几处，默认替换全部，</li>
<li>flags：功能标志位,扩展正则表达式的匹配。</li>
</ul>
<h4 id="5-re-search"><a href="#5-re-search" class="headerlink" title="5) re.search()"></a>5) re.search()</h4><p>匹配目标字符串第一个符合的内容，<strong>返回</strong>值为<strong>匹配的对象</strong>。语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">re.search(pattern,string,flags=0)</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li>pattern：正则表达式</li>
<li>string：目标字符串</li>
</ul>
<h2 id="2-flags功能标志位"><a href="#2-flags功能标志位" class="headerlink" title="2)flags功能标志位"></a>2)flags功能标志位</h2><p>功能标志位的作用是扩展正则表达的匹配功能。常用的 flag 如下所示：</p>
<table>
<thead>
<tr>
<th>缩写元字符</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>元字符只能匹配 ASCII码。</td>
</tr>
<tr>
<td>I</td>
<td>匹配忽略字母大小写。</td>
</tr>
<tr>
<td>S</td>
<td>使得<code>.</code>元字符可以匹配换行符。</td>
</tr>
<tr>
<td>M</td>
<td>使 ^ $ 可以匹配每一行的开头和结尾位置。</td>
</tr>
</tbody></table>
<p>注意：可以同时使用福多个功能标志位，比如 flags&#x3D;re.I|re.S。</p>
<p>下面使用贪婪和非贪婪两种模式来匹配 HTML 元素，分别，如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">html = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;div&gt;&lt;p&gt;www.biancheng.net&lt;/p&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;div&gt;&lt;p&gt;编程帮&lt;/p&gt;&lt;/div&gt;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># .S可以匹配到换行符</span></span><br><span class="line"><span class="comment"># 贪婪匹配</span></span><br><span class="line">pattern = re.<span class="built_in">compile</span>(<span class="string">&#x27;&lt;div&gt;&lt;p&gt;.*&lt;/p&gt;&lt;/div&gt;&#x27;</span>, re.S)  <span class="comment"># 创建正则表达式对象</span></span><br><span class="line">re_list = pattern.findall(html)  <span class="comment"># 通过正则表达式对象来匹配html元素，提取信息</span></span><br><span class="line"><span class="built_in">print</span>(re_list)</span><br><span class="line"><span class="comment"># 非贪婪匹配</span></span><br><span class="line">pattern2 = re.<span class="built_in">compile</span>(<span class="string">&#x27;&lt;div&gt;&lt;p&gt;.*?&lt;/p&gt;&lt;/div&gt;&#x27;</span>, re.S)  <span class="comment"># 创建正则表达式对象</span></span><br><span class="line">re_list2 = pattern.findall(html)  <span class="comment"># 通过正则表达式对象来匹配html元素，提取信息</span></span><br><span class="line"><span class="built_in">print</span>(re_list2)</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;&lt;div&gt;&lt;p&gt;www.biancheng.net&lt;/p&gt;&lt;/div&gt;\n&lt;div&gt;&lt;p&gt;编程帮&lt;/p&gt;&lt;/div&gt;&#x27;]</span><br><span class="line">[&#x27;&lt;div&gt;&lt;p&gt;www.biancheng.net&lt;/p&gt;&lt;/div&gt;\n&lt;div&gt;&lt;p&gt;编程帮&lt;/p&gt;&lt;/div&gt;&#x27;]</span><br></pre></td></tr></table></figure>

<p>从上述输出结果可以得出非贪婪模式比适合提取 HTML 信息。</p>
<h2 id="3-正则表达式分组"><a href="#3-正则表达式分组" class="headerlink" title="3)正则表达式分组"></a>3)正则表达式分组</h2><p>通过正则表达式分组可以从匹配的信息中提取出想要的信息。示例演示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment"># 正则表达式分组</span></span><br><span class="line">website = <span class="string">&quot;编程帮 www.biancheng.net&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 提取所有信息</span></span><br><span class="line"><span class="comment"># | .    | 匹配除换行符以外的任意字符           |</span></span><br><span class="line"><span class="comment"># | \w   | 匹配所有普通字符(数字、字母或下划线) |</span></span><br><span class="line"><span class="comment"># | \s   | 匹配任意的空白符                     |</span></span><br><span class="line"><span class="comment"># 注意此时正则表达式的 &quot;.&quot; 需要转义因此使用 \.</span></span><br><span class="line">pattern_1 = re.<span class="built_in">compile</span>(<span class="string">&#x27;\w+\s+\w+\.\w+\.\w+&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(pattern_1.findall(website))</span><br><span class="line"><span class="comment"># 提取匹配信息的第一项</span></span><br><span class="line">pattern_2 = re.<span class="built_in">compile</span>(<span class="string">&#x27;(\w+)\s+\w+\.\w+\.\w+&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(pattern_2.findall(website))</span><br><span class="line"><span class="comment"># 有两个及以上的()则以元组形式显示</span></span><br><span class="line">pattern_3 = re.<span class="built_in">compile</span>(<span class="string">&#x27;(\w+)\s+(\w+\.\w+\.\w+)&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(pattern_3.findall(website))</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&#x27;编程帮 www.biancheng.net&#x27;]</span><br><span class="line">[&#x27;编程帮&#x27;]</span><br><span class="line">[(&#x27;编程帮&#x27;, &#x27;www.biancheng.net&#x27;)]</span><br></pre></td></tr></table></figure>

<p>正则表达式分组是提取信息的常用方式。当需要哪个特定信息的时候，就可以通过分组(也就是加括号)的方式获得。</p>
<h2 id="4-网页信息提取"><a href="#4-网页信息提取" class="headerlink" title="4)网页信息提取"></a>4)网页信息提取</h2><p>实战演练：从下面的 HTML 代码中使用 re 模块提取出两部影片的名称和主演信息。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line">html = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&lt;div class=&quot;movie-item-info&quot;&gt;</span></span><br><span class="line"><span class="string">&lt;p class=&quot;name&quot;&gt;</span></span><br><span class="line"><span class="string">&lt;a title=&quot;你好，李焕英&quot;&gt;你好，李焕英&lt;/a&gt;</span></span><br><span class="line"><span class="string">&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;p class=&quot;star&quot;&gt;</span></span><br><span class="line"><span class="string">主演：贾玲,张小斐,沈腾</span></span><br><span class="line"><span class="string">&lt;/p&gt;    </span></span><br><span class="line"><span class="string">&lt;/div&gt;</span></span><br><span class="line"><span class="string">&lt;div class=&quot;movie-item-info&quot;&gt;</span></span><br><span class="line"><span class="string">&lt;p class=&quot;name&quot;&gt;</span></span><br><span class="line"><span class="string">&lt;a title=&quot;刺杀，小说家&quot;&gt;刺杀，小说家&lt;/a&gt;</span></span><br><span class="line"><span class="string">&lt;/p&gt;</span></span><br><span class="line"><span class="string">&lt;p class=&quot;star&quot;&gt;</span></span><br><span class="line"><span class="string">主演：雷佳音,杨幂,董子健,于和伟</span></span><br><span class="line"><span class="string">&lt;/p&gt;    </span></span><br><span class="line"><span class="string">&lt;/div&gt; </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 创建正则表达式对象， 分组提取title和star信息</span></span><br><span class="line">pattern = re.<span class="built_in">compile</span>(<span class="string">&#x27;&lt;div.*?&lt;a title=&quot;(.*?)&quot;.*?star&quot;&gt;(.*?)&lt;/p.*?div&gt;&#x27;</span>, re.S)</span><br><span class="line">re_list = pattern.findall(html)</span><br><span class="line"><span class="built_in">print</span>(re_list)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式化输出</span></span><br><span class="line"><span class="keyword">if</span> re_list:</span><br><span class="line">    <span class="keyword">for</span> re_info <span class="keyword">in</span> re_list:</span><br><span class="line">        <span class="built_in">print</span>(<span class="number">20</span> * <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;电影名称：&#x27;</span>, re_info[<span class="number">0</span>])</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;电影主演：&#x27;</span>, re_info[<span class="number">1</span>].strip())  <span class="comment"># 使用strip()函数去除主演字符串首尾的&#x27;\n&#x27;</span></span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[(&#x27;你好，李焕英&#x27;, &#x27;\n主演：贾玲,张小斐,沈腾\n&#x27;), (&#x27;刺杀，小说家&#x27;, &#x27;\n主演：雷佳音,杨幂,董子健,于和伟\n&#x27;)]</span><br><span class="line">--------------------</span><br><span class="line">电影名称： 你好，李焕英</span><br><span class="line">电影主演： 主演：贾玲,张小斐,沈腾</span><br><span class="line">--------------------</span><br><span class="line">电影名称： 刺杀，小说家</span><br><span class="line">电影主演： 主演：雷佳音,杨幂,董子健,于和伟</span><br></pre></td></tr></table></figure>

<h1 id="八、Python-csv模块（读写文件）"><a href="#八、Python-csv模块（读写文件）" class="headerlink" title="八、Python csv模块（读写文件）"></a>八、Python csv模块（读写文件）</h1><p>CSV 文件又称为逗号分隔值文件，是一种通用的、相对简单的文件格式，用以存储表格数据，包括数字或者字符。CSV 是电子表格和数据库中最常见的输入、输出文件格式，可参考《<a href="https://baike.baidu.com/item/CSV/10739?fr=aladdin">CSV介绍</a>》。</p>
<p>通过爬虫将数据抓取下来，然后把数据保存在文件，或者数据库中，这个过程称为数据的持久化存储。本节介绍 Python 内置模块 CSV 的读写操作。</p>
<h2 id="1-CSV文件写入"><a href="#1-CSV文件写入" class="headerlink" title="1)CSV文件写入"></a>1)CSV文件写入</h2><h4 id="1-csv-writer"><a href="#1-csv-writer" class="headerlink" title="1) csv.writer()"></a>1) csv.writer()</h4><p>csv 模块中的 writer 类可用于读写序列化的数据，其语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">writer(csvfile, dialect=&#x27;excel&#x27;, **fmtparams)</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li>csvfile：必须是支持迭代(Iterator)的对象，可以是文件(file)对象或者列表(list)对象。</li>
<li>dialect：编码风格，默认为 excel 的风格，也就是使用逗号<code>,</code>分隔。</li>
<li>fmtparam：格式化参数，用来覆盖之前 dialect 对象指定的编码风格。</li>
</ul>
<p>示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="comment"># 操作文件对象时，需要添加newline参数逐行写入，否则会出现空行现象</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;eggs.csv&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line">    <span class="comment"># delimiter 指定分隔符，默认为逗号，这里指定为空格</span></span><br><span class="line">    <span class="comment"># quotechar 表示引用符</span></span><br><span class="line">    <span class="comment"># writerow 单行写入，列表格式传入数据</span></span><br><span class="line">    spamWriter = csv.writer(csvfile, delimiter=<span class="string">&#x27; &#x27;</span>, quotechar=<span class="string">&#x27;|&#x27;</span>)</span><br><span class="line">    spamWriter.writerow([<span class="string">&#x27;www.biancheng.net&#x27;</span>] * <span class="number">5</span> + [<span class="string">&#x27;how are you&#x27;</span>])</span><br><span class="line">    spamWriter.writerow([<span class="string">&#x27;hello world&#x27;</span>, <span class="string">&#x27;web site&#x27;</span>, <span class="string">&#x27;www.biancheng.net&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p>eggs.csv 文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">www.biancheng.net www.biancheng.net www.biancheng.net www.biancheng.net www.biancheng.net |how are you|</span><br><span class="line">|hello world| |web site| www.biancheng.net</span><br></pre></td></tr></table></figure>

<p>其中，quotechar 是引用符，当一段话中出现分隔符的时候，用引用符将这句话括起来，以能排除歧义。</p>
<p>如果想同时写入多行数据，需要使用 writerrows() 方法，代码如下所示：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;aggs.csv&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    writer = csv.writer(f)</span><br><span class="line">    <span class="comment"># 注意传入数据的格式为列表元组格式</span></span><br><span class="line">    writer.writerows([(<span class="string">&#x27;hello&#x27;</span>,<span class="string">&#x27;world&#x27;</span>), (<span class="string">&#x27;I&#x27;</span>,<span class="string">&#x27;love&#x27;</span>,<span class="string">&#x27;you&#x27;</span>)])</span><br></pre></td></tr></table></figure>

<p>aggs.csv文件内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello,world</span><br><span class="line">I,love,you</span><br></pre></td></tr></table></figure>

<h4 id="2-csv-DictWriter"><a href="#2-csv-DictWriter" class="headerlink" title="2) csv.DictWriter()"></a>2) csv.DictWriter()</h4><p>当然也可使用 DictWriter 类以字典的形式读写数据，使用示例如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;names.csv&#x27;</span>, <span class="string">&#x27;w&#x27;</span>, newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line">    <span class="comment"># 构建字段名称，也就是key</span></span><br><span class="line">    fieldnames = [<span class="string">&#x27;first_name&#x27;</span>, <span class="string">&#x27;last_name&#x27;</span>]</span><br><span class="line">    writer = csv.DictWriter(csvfile, fieldnames=fieldnames)</span><br><span class="line">    <span class="comment"># 写入字段名，当做表头</span></span><br><span class="line">    writer.writeheader()</span><br><span class="line">    <span class="comment"># 多行写入</span></span><br><span class="line">    writer.writerows([&#123;<span class="string">&#x27;first_name&#x27;</span>: <span class="string">&#x27;Baked&#x27;</span>, <span class="string">&#x27;last_name&#x27;</span>: <span class="string">&#x27;Beans&#x27;</span>&#125;, &#123;<span class="string">&#x27;first_name&#x27;</span>: <span class="string">&#x27;Lovely&#x27;</span>, <span class="string">&#x27;last_name&#x27;</span>: <span class="string">&#x27;Spam&#x27;</span>&#125;])</span><br><span class="line">    <span class="comment"># 单行写入</span></span><br><span class="line">    writer.writerow(&#123;<span class="string">&#x27;first_name&#x27;</span>: <span class="string">&#x27;Wonderful&#x27;</span>, <span class="string">&#x27;last_name&#x27;</span>: <span class="string">&#x27;Spam&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>

<p>name.csv 文件内容，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">first_name,last_name</span><br><span class="line">Baked,Beans</span><br><span class="line">Lovely,Spam</span><br><span class="line">Wonderful,Spam</span><br></pre></td></tr></table></figure>

<h2 id="2-CSV文件读取"><a href="#2-CSV文件读取" class="headerlink" title="2)CSV文件读取"></a>2)CSV文件读取</h2><h4 id="1-csv-reader"><a href="#1-csv-reader" class="headerlink" title="1) csv.reader()"></a>1) csv.reader()</h4><p>csv 模块中的 reader 类和 DictReader 类用于读取文件中的数据，其中 reader() 语法格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">csv.reader(csvfile, dialect=&#x27;excel&#x27;, **fmtparams)</span><br></pre></td></tr></table></figure>

<p>应用示例如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;eggs.csv&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line">    spamreader = csv.reader(csvfile, delimiter=<span class="string">&#x27; &#x27;</span>, quotechar=<span class="string">&#x27;|&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> spamreader:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;, &#x27;</span>.join(row))</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">www.biancheng.net, www.biancheng.net, www.biancheng.net, www.biancheng.net, www.biancheng.net, how are you</span><br><span class="line">hello world, web site, www.biancheng.net</span><br></pre></td></tr></table></figure>

<h4 id="2-csv-DictReader"><a href="#2-csv-DictReader" class="headerlink" title="2) csv.DictReader()"></a>2) csv.DictReader()</h4><p>应用示例如下：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;names.csv&#x27;</span>, newline=<span class="string">&#x27;&#x27;</span>) <span class="keyword">as</span> csvfile:</span><br><span class="line">    reader = csv.DictReader(csvfile)</span><br><span class="line">    <span class="keyword">for</span> row <span class="keyword">in</span> reader:</span><br><span class="line">        <span class="built_in">print</span>(row[<span class="string">&#x27;first_name&#x27;</span>], row[<span class="string">&#x27;last_name&#x27;</span>])</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Baked Beans</span><br><span class="line">Lovely Spam</span><br><span class="line">Wonderful Spam</span><br></pre></td></tr></table></figure>

<h1 id="九、【实例】Python爬虫抓取猫眼电影排行榜"><a href="#九、【实例】Python爬虫抓取猫眼电影排行榜" class="headerlink" title="九、【实例】Python爬虫抓取猫眼电影排行榜"></a>九、【实例】Python爬虫抓取猫眼电影排行榜</h1><p>本节使用 Python 爬虫抓取猫眼电影网 TOP100 排行榜（<a href="https://maoyan.com/board/4%EF%BC%89%E5%BD%B1%E7%89%87%E4%BF%A1%E6%81%AF%EF%BC%8C%E5%8C%85%E6%8B%AC%E7%94%B5%E5%BD%B1%E5%90%8D%E7%A7%B0%E3%80%81%E4%B8%8A%E6%98%A0%E6%97%B6%E9%97%B4%E3%80%81%E4%B8%BB%E6%BC%94%E4%BF%A1%E6%81%AF%E3%80%82">https://maoyan.com/board/4）影片信息，包括电影名称、上映时间、主演信息。</a></p>
<p>在开始编写程序之前，首先要确定页面类型（静态页面或动态页面），其次找出页面的 url 规律，最后通过分析网页元素结构来确定正则表达式，从而提取网页信息。</p>
<h2 id="1-确定页面类型"><a href="#1-确定页面类型" class="headerlink" title="1)确定页面类型"></a>1)确定页面类型</h2><p>点击右键查看页面源码，确定要抓取的数据是否存在于页面内。通过浏览得知要抓取的信息全部存在于源码内，因此该页面输属于静态页面。如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;movie-item-info&quot;&gt;        &lt;p class=&quot;name&quot;&gt;&lt;a href=&quot;/films/1200486&quot; title=&quot;我不是药神&quot; data-act=&quot;boarditem-click&quot; data-val=&quot;&#123;movieId:1200486&#125;&quot;&gt;我不是药神&lt;/a&gt;&lt;/p&gt;        &lt;p class=&quot;star&quot;&gt;                主演：徐峥,周一围,王传君        &lt;/p&gt;&lt;p class=&quot;releasetime&quot;&gt;上映时间：2018-07-05&lt;/p&gt;    &lt;/div&gt;</span><br></pre></td></tr></table></figure>

<h2 id="2-确定url规律"><a href="#2-确定url规律" class="headerlink" title="2)确定url规律"></a>2)确定url规律</h2><p>想要确定 url 规律，需要您多浏览几个页面，然后才可以总结出 url 规律，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一页：https://maoyan.com/board/4?offset=0</span><br><span class="line">第二页：https://maoyan.com/board/4?offset=10</span><br><span class="line">第三页：https://maoyan.com/board/4?offset=20</span><br><span class="line">...</span><br><span class="line">第n页：https://maoyan.com/board/4?offset=(n-1)*10</span><br></pre></td></tr></table></figure>

<h3 id="1-确定正则表达式"><a href="#1-确定正则表达式" class="headerlink" title="1)确定正则表达式"></a>1)确定正则表达式</h3><p>通过分析网页元素结构来确定正则表达式，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;movie-item-info&quot;&gt;        &lt;p class=&quot;name&quot;&gt;&lt;a href=&quot;/films/1200486&quot; title=&quot;我不是药神&quot; data-act=&quot;boarditem-click&quot; data-val=&quot;&#123;movieId:1200486&#125;&quot;&gt;我不是药神&lt;/a&gt;&lt;/p&gt;        &lt;p class=&quot;star&quot;&gt;                主演：徐峥,周一围,王传君        &lt;/p&gt;&lt;p class=&quot;releasetime&quot;&gt;上映时间：2018-07-05&lt;/p&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>使用 Chrome 开发者调试工具来精准定位要抓取信息的元素结构。之所以这样做，是因为这能避免正则表达式的冗余，提高编写正则表达式的速度。正则表达式如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;div class=&quot;movie-item-info&quot;&gt;.*?title=&quot;(.*?)&quot;.*?class=&quot;star&quot;&gt;(.*?)&lt;/p&gt;.*?releasetime&quot;&gt;(.*?)&lt;/p&gt;</span><br></pre></td></tr></table></figure>

<p>编写正则表达式时将需要提取的信息使用<code>(.*?)</code>代替，而不需要的内容（包括元素标签）使用<code>.*?</code>代替。</p>
<h2 id="3-编写爬虫程序-1"><a href="#3-编写爬虫程序-1" class="headerlink" title="3)编写爬虫程序"></a>3)编写爬虫程序</h2><p>下面使用面向对象的方法编写爬虫程序，主要编写四个函数，分别是请求函数、解析函数、保存数据函数、主函数。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> request</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> csv</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> ua_info <span class="keyword">import</span> ua_list</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个爬虫类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MaoYanSpider</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment"># 初始化</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.url = <span class="string">&#x27;https://www.maoyan.com/board/4?offset=&#123;&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 请求函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_html</span>(<span class="params">self, url</span>):</span><br><span class="line">        headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>: random.choice(ua_list)&#125;</span><br><span class="line">        <span class="comment"># req = request.Request(url, headers)</span></span><br><span class="line">        req = request.Request(url=url, headers=headers)</span><br><span class="line">        res = request.urlopen(req)</span><br><span class="line">        html = res.read().decode()</span><br><span class="line">        <span class="comment"># 调用解析函数</span></span><br><span class="line">        self.parse_html(html)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 解析函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">parse_html</span>(<span class="params">self, html</span>):</span><br><span class="line">        <span class="comment"># 正则表达式，并创建对象</span></span><br><span class="line">        pattern = <span class="string">&#x27;&lt;div class=&quot;movie-item-info&quot;&gt;.*?title=&quot;(.*?)&quot;.*?&quot;star&quot;&gt;(.*?)&lt;/p.*?&quot;releasetime&quot;&gt;(.*?)&lt;/p&gt;&#x27;</span></span><br><span class="line">        regex = re.<span class="built_in">compile</span>(pattern, re.S)</span><br><span class="line">        <span class="comment"># 列表元组</span></span><br><span class="line">        re_list = regex.findall(html)</span><br><span class="line">        <span class="built_in">print</span>(html)</span><br><span class="line">        <span class="built_in">print</span>(re_list)</span><br><span class="line">        <span class="comment"># 调用保存数据函数</span></span><br><span class="line">        self.save_html(re_list)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 保存数据函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">save_html</span>(<span class="params">self, re_list</span>):</span><br><span class="line">        <span class="comment"># 生成文件对象</span></span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;猫眼电影.csv&#x27;</span>, <span class="string">&#x27;a&#x27;</span>, newline=<span class="string">&#x27;&#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            <span class="comment"># 生成csv操作对象</span></span><br><span class="line">            writer = csv.writer(f)</span><br><span class="line">            <span class="comment"># 数据整理</span></span><br><span class="line">            <span class="keyword">for</span> r <span class="keyword">in</span> re_list:</span><br><span class="line">                name = r[<span class="number">0</span>].strip()</span><br><span class="line">                star = r[<span class="number">1</span>].strip()[<span class="number">3</span>:]</span><br><span class="line">                <span class="comment"># 切片获取上映时间 eg:上映时间：2018-07-05</span></span><br><span class="line">                time = r[<span class="number">2</span>].strip()[<span class="number">5</span>:<span class="number">15</span>]</span><br><span class="line">                Data = [name, star, time]</span><br><span class="line">                <span class="comment"># 写入csv文件</span></span><br><span class="line">                writer.writerow(Data)</span><br><span class="line">                <span class="built_in">print</span>(name, time, star)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 主函数</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 抓取第一页数据</span></span><br><span class="line">        <span class="keyword">for</span> offset <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">11</span>, <span class="number">10</span>):</span><br><span class="line">            url = self.url.<span class="built_in">format</span>(offset)</span><br><span class="line">            self.get_html(url)</span><br><span class="line">            <span class="comment"># 爬虫休眠--生成1-2之间的浮点数</span></span><br><span class="line">            time.sleep(random.uniform(<span class="number">1</span>, <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以脚本方式启动</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        spider = MaoYanSpider()</span><br><span class="line">        spider.run()</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;ERROR:&#x27;</span>, e)</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p>我不是药神 2018-07-05 徐峥,周一围,王传君<br>肖申克的救赎 1994-09-10 蒂姆·罗宾斯,摩根·弗里曼,鲍勃·冈顿<br>绿皮书 2019-03-01 维果·莫腾森,马赫沙拉·阿里,琳达·卡德里尼<br>海上钢琴师 2019-11-15 蒂姆·罗斯,比尔·努恩,克兰伦斯·威廉姆斯三世<br>小偷家族 2018-08-03 中川雅也,安藤樱,松冈茉优<br>霸王别姬 1993-07-26 张国荣,张丰毅,巩俐<br>哪吒之魔童降世 2019-07-26 吕艳婷,囧森瑟夫,瀚墨<br>美丽人生 2020-01-03 罗伯托·贝尼尼,朱斯蒂诺·杜拉诺,赛尔乔·比尼·布斯特里克<br>这个杀手不太冷 1994-09-14 让·雷诺,加里·奥德曼,娜塔莉·波特曼<br>盗梦空间 2010-09-01 莱昂纳多·迪卡普里奥,渡边谦,约瑟夫·高登-莱维特</p>
<h1 id="十、【实例】-Python-Pymysql实现数据存储"><a href="#十、【实例】-Python-Pymysql实现数据存储" class="headerlink" title="十、【实例】 Python Pymysql实现数据存储"></a>十、【实例】 Python Pymysql实现数据存储</h1><h1 id="十一、【实例】Python爬虫：抓取多级页面数据"><a href="#十一、【实例】Python爬虫：抓取多级页面数据" class="headerlink" title="十一、【实例】Python爬虫：抓取多级页面数据"></a>十一、【实例】Python爬虫：抓取多级页面数据</h1><h1 id="十二、【实例】Python-Requests库安装和使用"><a href="#十二、【实例】Python-Requests库安装和使用" class="headerlink" title="十二、【实例】Python Requests库安装和使用"></a>十二、【实例】Python Requests库安装和使用</h1><p>Python 提供了多个用来编写爬虫程序的库，除了前面已经介绍的 urllib 库之外，还有一个很重的 Requests 库，这个库的宗旨是“让 HTTP 服务于人类”。</p>
<p><img src="9-210R0113914536.gif" alt="Python requests"></p>
<p>Requests 是 Python 的第三方库，它的安装非常简便，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python -m pip install requests</span><br></pre></td></tr></table></figure>

<p>Requests 库是在 urllib 的基础上开发而来，它使用 Python 语言编写，并且采用了 Apache2 Licensed（一种开源协议）的 HTTP 库。与 urllib 相比，Requests 更加方便、快捷，因此在编写爬虫程序时 Requests 库使用较多。</p>
<h2 id="1-常用请求方法"><a href="#1-常用请求方法" class="headerlink" title="1) 常用请求方法"></a>1) 常用请求方法</h2><h4 id="1-requests-get"><a href="#1-requests-get" class="headerlink" title="1) requests.get()"></a>1) requests.get()</h4><p>该方法用于 GET 请求，表示向网站发起请求，获取页面响应对象。语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">res = requests.get(url,headers=headers,params,timeout)</span><br></pre></td></tr></table></figure>

<p>参数说明如下：</p>
<ul>
<li>url：要抓取的 url 地址。</li>
<li>headers：用于包装请求头信息。</li>
<li>params：请求时携带的查询字符串参数。</li>
<li>timeout：超时时间，超过时间会抛出异常。</li>
</ul>
<p>具体使用示例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import requestsurl = &#x27;http://baidu.com&#x27;response = requests.get(url)print(response)</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Response [200]&gt;</span><br></pre></td></tr></table></figure>

<p>获取带查询字符串参数的响应对象，如下所示：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;编程帮&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;url&#x27;</span>: <span class="string">&quot;www.biancheng.net&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">response = requests.get(<span class="string">&#x27;http://httpbin.org/get&#x27;</span>, params=data)</span><br><span class="line"><span class="comment">#直接拼接参数也可以</span></span><br><span class="line"><span class="comment">#response = requests.get(http://httpbin.org/get?name=gemey&amp;age=22)</span></span><br><span class="line"><span class="comment">#调用响应对象text属性，获取文本信息</span></span><br><span class="line"><span class="built_in">print</span>(response.text)</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;args&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;\u7f16\u7a0b\u5e2e&quot;,</span><br><span class="line">    &quot;url&quot;: &quot;www.biancheng.net&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;headers&quot;: &#123;</span><br><span class="line">    &quot;Accept&quot;: &quot;*/*&quot;,</span><br><span class="line">    &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;,</span><br><span class="line">    &quot;Host&quot;: &quot;httpbin.org&quot;,</span><br><span class="line">    &quot;User-Agent&quot;: &quot;python-requests/2.23.0&quot;,</span><br><span class="line">    &quot;X-Amzn-Trace-Id&quot;: &quot;Root=1-60420026-236f9205646b68706d0fafa7&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;origin&quot;: &quot;121.17.25.194&quot;,</span><br><span class="line">  &quot;url&quot;: &quot;http://httpbin.org/get?name=\u7f16\u7a0b\u5e2e&amp;url=www.biancheng.net&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-requests-post"><a href="#2-requests-post" class="headerlink" title="2) requests.post()"></a>2) requests.post()</h4><p>该方法用于 POST 请求，先由用户向目标 url 提交数据，然后服务器返回一个 HttpResponse 响应对象，语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">response=requests.post(url,data=&#123;请求体的字典&#125;)</span><br></pre></td></tr></table></figure>

<p>示例如下所示：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="comment">#百度翻译</span></span><br><span class="line">url = <span class="string">&#x27;https://fanyi.baidu.com&#x27;</span></span><br><span class="line"><span class="comment">#post请求体携带的参数，可通过开发者调试工具查看</span></span><br><span class="line"><span class="comment">#查看步骤：NetWork选项-&gt;Headers选项-&gt;Form Data</span></span><br><span class="line">data = &#123;<span class="string">&#x27;from&#x27;</span>: <span class="string">&#x27;zh&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;to&#x27;</span>: <span class="string">&#x27;en&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;query&#x27;</span>: <span class="string">&#x27;编程帮www.biancheng.net你好&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">response = requests.post(url, data=data)</span><br><span class="line"><span class="built_in">print</span>(response)</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;Response [200]&gt;</span><br></pre></td></tr></table></figure>

<p>查看 Form Data 的步骤，如下图所示：</p>
<p><img src="9-210Q9131356309.gif" alt="Python爬重开发者工具使用"></p>
<p>图1：Chrome开发者调试工具（<a href="http://c.biancheng.net/uploads/allimg/210819/9-210Q9131356309.gif">点击看高清图</a>）</p>
<h2 id="2-对象属性"><a href="#2-对象属性" class="headerlink" title="2) 对象属性"></a>2) 对象属性</h2><p>当我们使用 Requests 模块向一个 URL 发起请求后会返回一个 HttpResponse 响应对象，该对象具有以下常用属性：</p>
<table>
<thead>
<tr>
<th>常用属性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>encoding</td>
<td>查看或者指定响应字符编码</td>
</tr>
<tr>
<td>status_code</td>
<td>返回HTTP响应码</td>
</tr>
<tr>
<td>url</td>
<td>查看请求的 url 地址</td>
</tr>
<tr>
<td>headers</td>
<td>查看请求头信息</td>
</tr>
<tr>
<td>cookies</td>
<td>查看cookies 信息</td>
</tr>
<tr>
<td>text</td>
<td>以字符串形式输出</td>
</tr>
<tr>
<td>content</td>
<td>以字节流形式输出，若要保存下载图片需使用该属性。</td>
</tr>
</tbody></table>
<p>使用示例如下所示：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">response = requests.get(<span class="string">&#x27;http://www.baidu.com&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(response.encoding)</span><br><span class="line">response.encoding=<span class="string">&quot;utf-8&quot;</span>    <span class="comment">#更改为utf-8编码</span></span><br><span class="line"><span class="built_in">print</span>(response.status_code)  <span class="comment"># 打印状态码</span></span><br><span class="line"><span class="built_in">print</span>(response.url)          <span class="comment"># 打印请求url</span></span><br><span class="line"><span class="built_in">print</span>(response.headers)      <span class="comment"># 打印头信息</span></span><br><span class="line"><span class="built_in">print</span>(response.cookies)      <span class="comment"># 打印cookie信息</span></span><br><span class="line"><span class="built_in">print</span>(response.text)  <span class="comment">#以字符串形式打印网页源码</span></span><br><span class="line"><span class="built_in">print</span>(response.content) <span class="comment">#以字节流形式打印</span></span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#编码格式</span><br><span class="line">ISO-8859-1</span><br><span class="line">#响应码</span><br><span class="line">200</span><br><span class="line">#url地址</span><br><span class="line">http://www.baidu.com/</span><br><span class="line">#请求头信息</span><br><span class="line">&#123;&#x27;Cache-Control&#x27;: &#x27;private, no-cache, no-store, proxy-revalidate, no-transform&#x27;, &#x27;Connection&#x27;: &#x27;keep-alive&#x27;, &#x27;Content-Encoding&#x27;: &#x27;gzip&#x27;, &#x27;Content-Type&#x27;: &#x27;text/html&#x27;, &#x27;Date&#x27;: &#x27;Mon, 08 Mar 2021 05:19:33 GMT&#x27;, &#x27;Last-Modified&#x27;: &#x27;Mon, 23 Jan 2017 13:27:29 GMT&#x27;, &#x27;Pragma&#x27;: &#x27;no-cache&#x27;, &#x27;Server&#x27;: &#x27;bfe/1.0.8.18&#x27;, &#x27;Set-Cookie&#x27;: &#x27;BDORZ=27315; max-age=86400; domain=.baidu.com; path=/&#x27;, &#x27;Transfer-Encoding&#x27;: &#x27;chunked&#x27;&#125;</span><br><span class="line">#查看cookies信息</span><br><span class="line">&lt;RequestsCookieJar[&lt;Cookie BDORZ=27315 for .baidu.com/&gt;]&gt;</span><br><span class="line">...内容过长，此处省略后两项输出</span><br></pre></td></tr></table></figure>

<h2 id="3-Requests库应用"><a href="#3-Requests库应用" class="headerlink" title="3) Requests库应用"></a>3) Requests库应用</h2><p>示例应用：使用 Requsets 库下载百度图片。</p>
<p>首先打开百度图片（<a href="https://image.baidu.com/%EF%BC%89%EF%BC%8C%E5%B9%B6%E5%9C%A8%E8%BE%93%E5%85%A5%E6%A1%86%E6%90%9C%E7%B4%A2">https://image.baidu.com/），并在输入框搜索</a> “python logo”，然后使用 Chrome 开发者工具查看第一张图片的源地址，即 data-imgurl 所对应的 url 地址，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data-imgurl=&quot;https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=38785274,1357847304&amp;fm=26&amp;gp=0.jpg&quot;</span><br></pre></td></tr></table></figure>

<p>可以将上述 url 粘贴至浏览器地址栏进行验证。当我们确定图片地址后，就可以使用 requests 库进行编码了：</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url = <span class="string">&#x27;https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=38785274,1357847304&amp;fm=26&amp;gp=0.jpg&#x27;</span></span><br><span class="line"><span class="comment"># 简单定义浏览器ua信息</span></span><br><span class="line">headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/4.0&#x27;</span>&#125;</span><br><span class="line"><span class="comment"># 读取图片需要使用content属性</span></span><br><span class="line">html = requests.get(url=url, headers=headers).content</span><br><span class="line"><span class="comment"># 以二进制的方式下载图片</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;C:/Users/Administrator/Desktop/image/python_logo.jpg&#x27;</span>, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(html)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>最后，您会在桌面文件夹中找到已经下载好的图片</p>
<h1 id="十三、【实例】Python爬虫抓取网络照片"><a href="#十三、【实例】Python爬虫抓取网络照片" class="headerlink" title="十三、【实例】Python爬虫抓取网络照片"></a>十三、【实例】Python爬虫抓取网络照片</h1><p>本节编写一个快速下载照片的程序，通过百度图片下载您想要的前 60 张图片，并将其保存至相应的目录。本节实战案例是上一节《<a href="http://c.biancheng.net/python_spider/requests.html">Python Request库安装和使用</a>》图片下载案例的延伸。</p>
<h2 id="1-分析url规律"><a href="#1-分析url规律" class="headerlink" title="1) 分析url规律"></a>1) 分析url规律</h2><p>打开百度图片翻页版（<a href="http://image.baidu.com/search/flip?tn=baiduimage&ie=utf-8&word=python&pn=0&gsm=50&ct=&ic=0&lm=-1&width=0&height=0">点击访问</a>），该翻页版网址要妥善保留。其 url 规律如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一页：https://image.baidu.com/search/flip?tn=baiduimage&amp;word=python&amp;pn=0</span><br><span class="line">第二页：https://image.baidu.com/search/flip?tn=baiduimage&amp;word=python&amp;pn=20</span><br><span class="line">第三页：https://image.baidu.com/search/flip?tn=baiduimage&amp;word=python&amp;pn=40</span><br><span class="line">第n页：https://image.baidu.com/search/flip?tn=baiduimage&amp;word=python&amp;pn=20*（n-1)</span><br></pre></td></tr></table></figure>

<p>百度为了限制爬虫，将原来的翻页版变为了“瀑布流”浏览形式，也就是通过滚动滑轮自动加载图片，此种方式在一定程度上限制了爬虫程序。</p>
<h2 id="2-写正则表达式"><a href="#2-写正则表达式" class="headerlink" title="2) 写正则表达式"></a>2) 写正则表达式</h2><p>通过上一节可以得知每一张图片有一个源地址如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">data-imgurl=&quot;图片源地址&quot;</span><br></pre></td></tr></table></figure>

<p>复制图片源地址，并检查网页源代码，使用 Ctrl+F 搜索该地址，如下图所示：</p>
<p><img src="9-210Q91336203T.png" alt="request模块使用"></p>
<p>图1：检查网页结构（<a href="http://c.biancheng.net/uploads/allimg/210819/9-210Q91336203T.png">点击看高清图</a>）</p>
<p>使用上述方式依次检查几张图片，您会发现每张图片源地址，有如下三种匹配结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;thumbURL&quot;:&quot;https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=38785274,1357847304&amp;fm=26&amp;gp=0.jpg&quot;</span><br><span class="line">&quot;middleURL&quot;:&quot;https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=38785274,1357847304&amp;fm=26&amp;gp=0.jpg&quot;</span><br><span class="line">&quot;hoverURL&quot;:&quot;https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=38785274,1357847304&amp;fm=26&amp;gp=0.jpg&quot;</span><br></pre></td></tr></table></figure>

<p>任选其一，写出图片源地址正则表达式，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">re_bds=&#x27;&quot;hoverURL&quot;:&quot;(.*?)&quot;&#x27;</span><br></pre></td></tr></table></figure>

<h2 id="3-编写程序代码"><a href="#3-编写程序代码" class="headerlink" title="3) 编写程序代码"></a>3) 编写程序代码</h2><p>下面使用 Requests 库的相应方法和属性编写程序代码，最终实现一个快速下载照片的小程序。</p>
<figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding:utf8 -*-</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">from</span> urllib <span class="keyword">import</span> parse</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaiduImageSpider</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.url = <span class="string">&#x27;https://image.baidu.com/search/flip?tn=baiduimage&amp;word=&#123;&#125;&#x27;</span></span><br><span class="line">        self.headers = &#123;<span class="string">&#x27;User-Agent&#x27;</span>:<span class="string">&#x27;Mozilla/4.0&#x27;</span>&#125;</span><br><span class="line">    <span class="comment"># 获取图片</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_image</span>(<span class="params">self,url,word</span>):</span><br><span class="line">        <span class="comment">#使用 requests模块得到响应对象</span></span><br><span class="line">        res= requests.get(url,headers=self.headers)</span><br><span class="line">        <span class="comment"># 更改编码格式</span></span><br><span class="line">        res.encoding=<span class="string">&quot;utf-8&quot;</span></span><br><span class="line">        <span class="comment"># 得到html网页</span></span><br><span class="line">        html=res.text</span><br><span class="line">        <span class="built_in">print</span>(html)</span><br><span class="line">        <span class="comment">#正则解析</span></span><br><span class="line">        pattern = re.<span class="built_in">compile</span>(<span class="string">&#x27;&quot;hoverURL&quot;:&quot;(.*?)&quot;&#x27;</span>,re.S)</span><br><span class="line">        img_link_list = pattern.findall(html)</span><br><span class="line">        <span class="comment">#存储图片的url链接 </span></span><br><span class="line">        <span class="built_in">print</span>(img_link_list)</span><br><span class="line">        <span class="comment"># 创建目录，用于保存图片</span></span><br><span class="line">        directory = <span class="string">&#x27;C:/Users/Administrator/Desktop/image/&#123;&#125;/&#x27;</span>.<span class="built_in">format</span>(word)</span><br><span class="line">        <span class="comment"># 如果目录不存在则创建，此方法常用</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(directory):</span><br><span class="line">            os.makedirs(directory)</span><br><span class="line">        </span><br><span class="line">        <span class="comment">#添加计数 </span></span><br><span class="line">        i = <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> img_link <span class="keyword">in</span> img_link_list:</span><br><span class="line">            filename = <span class="string">&#x27;&#123;&#125;&#123;&#125;_&#123;&#125;.jpg&#x27;</span>.<span class="built_in">format</span>(directory, word, i)</span><br><span class="line">            self.save_image(img_link,filename)</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">    <span class="comment">#下载图片</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">save_image</span>(<span class="params">self,img_link,filename</span>):</span><br><span class="line">        html = requests.get(url=img_link,headers=self.headers).content</span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(filename,<span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">            f.write(html)</span><br><span class="line">        <span class="built_in">print</span>(filename,<span class="string">&#x27;下载成功&#x27;</span>)</span><br><span class="line">    <span class="comment"># 入口函数 </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        word = <span class="built_in">input</span>(<span class="string">&quot;您想要谁的照片？&quot;</span>)</span><br><span class="line">        word_parse = parse.quote(word)</span><br><span class="line">        url = self.url.<span class="built_in">format</span>(word_parse)</span><br><span class="line">        self.get_image(url,word)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    spider = BaiduImageSpider()</span><br><span class="line">    spider.run()</span><br></pre></td></tr></table></figure>

<p>程序执行结果如下图：</p>
<p><img src="9-210Q91336322E.png" alt="程序执行结果"><br>图2：程序执行图</p>
<p>目录文件下载图如下所示：</p>
<p><img src="9-210Q9133642311.png" alt="python爬虫实战"><br>图3：程序执行结果</p>
<h1 id="Python-Selenium"><a href="#Python-Selenium" class="headerlink" title="Python Selenium"></a>Python Selenium</h1><h2 id="1-【实例】抓取京东商城信息"><a href="#1-【实例】抓取京东商城信息" class="headerlink" title="1.【实例】抓取京东商城信息"></a>1.【实例】抓取京东商城信息</h2><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment"># coding:utf8</span></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.common.by <span class="keyword">import</span> By</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JdSpider</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.url = <span class="string">&#x27;http://www.jd.com/&#x27;</span></span><br><span class="line">        self.options = webdriver.ChromeOptions()  <span class="comment"># 无头模式</span></span><br><span class="line">        self.options.add_argument(<span class="string">&#x27;--headless&#x27;</span>)</span><br><span class="line">        self.browser = webdriver.Chrome(options=self.options)  <span class="comment"># 创建无界面参数的浏览器对象</span></span><br><span class="line">        self.i = <span class="number">0</span>  <span class="comment"># 计数，一共有多少件商品</span></span><br><span class="line">        <span class="comment"># 输入地址+输入商品+点击按钮，切记这里元素节点是京东首页的输入栏、搜索按钮</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_html</span>(<span class="params">self</span>):</span><br><span class="line">        self.browser.get(self.url)</span><br><span class="line">        self.browser.find_element(By.XPATH, value=<span class="string">&#x27;//*[@id=&quot;key&quot;]&#x27;</span>).send_keys(<span class="string">&#x27;python书籍&#x27;</span>)</span><br><span class="line">        self.browser.find_element(By.XPATH, value=<span class="string">&quot;//*[@class=&#x27;form&#x27;]/button&quot;</span>).click()</span><br><span class="line">        <span class="comment"># 把进度条件拉倒最底部+提取商品信息</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_data</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 执行js语句，拉动进度条件</span></span><br><span class="line">        self.browser.execute_script(</span><br><span class="line">            <span class="string">&#x27;window.scrollTo(0,document.body.scrollHeight)&#x27;</span></span><br><span class="line">        )</span><br><span class="line">        <span class="comment"># 给页面元素加载时预留时间</span></span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line">        <span class="comment"># 用 xpath 提取每页中所有商品，最终形成一个大列表</span></span><br><span class="line">        li_list = self.browser.find_elements(By.XPATH, value=<span class="string">&#x27;//*[@id=&quot;J_goodsList&quot;]/ul/li&#x27;</span>)</span><br><span class="line">        <span class="keyword">for</span> li <span class="keyword">in</span> li_list:</span><br><span class="line">            <span class="comment"># 构建空字典</span></span><br><span class="line">            item = &#123;&#125;</span><br><span class="line">            item[<span class="string">&#x27;name&#x27;</span>] = li.find_element(By.XPATH, value=<span class="string">&#x27;.//div[@class=&quot;p-name&quot;]/a/em&#x27;</span>).text.strip()</span><br><span class="line">            item[<span class="string">&#x27;price&#x27;</span>] = li.find_element(By.XPATH, value=<span class="string">&#x27;.//div[@class=&quot;p-price&quot;]&#x27;</span>).text.strip()</span><br><span class="line">            item[<span class="string">&#x27;count&#x27;</span>] = li.find_element(By.XPATH, value=<span class="string">&#x27;.//div[@class=&quot;p-commit&quot;]/strong&#x27;</span>).text.strip()</span><br><span class="line">            item[<span class="string">&#x27;shop&#x27;</span>] = li.find_element(By.XPATH, value=<span class="string">&#x27;.//div[@class=&quot;p-shopnum&quot;]&#x27;</span>).text.strip()</span><br><span class="line">            <span class="built_in">print</span>(item)</span><br><span class="line">            self.i += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="comment"># 搜索出想要抓取商品的页面</span></span><br><span class="line">        self.get_html()</span><br><span class="line">        <span class="comment"># 循环执行点击“下一页”操作</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># 获取每一页要抓取的数据</span></span><br><span class="line">            self.get_data()</span><br><span class="line">            <span class="comment"># 判断是否是最一页</span></span><br><span class="line">            <span class="keyword">if</span> self.browser.page_source.find(<span class="string">&#x27;pn-next disabled&#x27;</span>) == -<span class="number">1</span>:</span><br><span class="line">                self.browser.find_element(By.CLASS_NAME, value=<span class="string">&#x27;pn-next&#x27;</span>).click()</span><br><span class="line">                <span class="comment"># 预留元素加载时间</span></span><br><span class="line">                time.sleep(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;数量&#x27;</span>, self.i)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    spider = JdSpider()</span><br><span class="line">    spider.run()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>Python,爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>C++图形库Qt-学习笔记(持续更新中...)</title>
    <url>/2022/08/17/QtNode/</url>
    <content><![CDATA[<h1 id="一-Clion中创建Qt类的相关模板"><a href="#一-Clion中创建Qt类的相关模板" class="headerlink" title="一.Clion中创建Qt类的相关模板"></a>一.Clion中创建Qt类的相关模板</h1><h2 id="1-原模板："><a href="#1-原模板：" class="headerlink" title="1.原模板："></a>1.原模板：</h2><h3 id="Qt-Class-Header-h"><a href="#Qt-Class-Header-h" class="headerlink" title="Qt Class Header.h"></a>Qt Class Header.h</h3><p>#parse(“C File Header.h”)<br>#[[#ifndef]]# ${INCLUDE_GUARD}<br>#[[#define]]# ${INCLUDE_GUARD}</p>
<p>#[[#include]]# &lt;${PARENT_CLASS}&gt;</p>
<p>${USER_BEGIN_NAMESPACE}<br>QT_BEGIN_NAMESPACE<br>namespace Ui { class ${NAME}; }<br>QT_END_NAMESPACE</p>
<p>class ${NAME} : public ${PARENT_CLASS} {<br>Q_OBJECT</p>
<p>public:<br>    explicit ${NAME}(QWidget *parent &#x3D; nullptr);<br>    ~${NAME}() override;</p>
<p>private:<br>    Ui::${NAME} *ui;<br>};<br>${USER_END_NAMESPACE}</p>
<p>#[[#endif]]# &#x2F;&#x2F;${INCLUDE_GUARD}</p>
<h3 id="Qt-class-cpp"><a href="#Qt-class-cpp" class="headerlink" title="Qt class.cpp"></a>Qt class.cpp</h3><p>#parse(“C File Header.h”)<br>&#x2F;&#x2F; You may need to build the project (run Qt uic code generator) to get “${UI_HEADER_FILENAME}” resolved</p>
<p>#[[#include]]# “${HEADER_FILENAME}”<br>#[[#include]]# “${UI_HEADER_FILENAME}”</p>
<p>${USER_BEGIN_NAMESPACE}<br>${NAME}::${NAME}(QWidget *parent) :<br>    ${PARENT_CLASS}(parent), ui(new Ui::${NAME}) {<br>    ui-&gt;setupUi(this);<br>}</p>
<p>${NAME}::~${NAME}() {<br>    delete ui;<br>}<br>${USER_END_NAMESPACE}&#96;</p>
<h2 id="2-普通模板："><a href="#2-普通模板：" class="headerlink" title="2.普通模板："></a>2.普通模板：</h2><h3 id="Qt-Class-Header-h-1"><a href="#Qt-Class-Header-h-1" class="headerlink" title="Qt Class Header.h"></a>Qt Class Header.h</h3><p>#parse(“C File Header.h”)</p>
<p>#[[#ifndef]]# ${INCLUDE_GUARD}<br>#[[#define]]# ${INCLUDE_GUARD}</p>
<p>#[[#include]]# &lt;${PARENT_CLASS}&gt;<br>#[[#include]]# “${UI_HEADER_FILENAME}”</p>
<p>class ${NAME} : public ${PARENT_CLASS} {</p>
<p>};</p>
<p>#[[#endif]]# &#x2F;&#x2F;${INCLUDE_GUARD}</p>
<h3 id="Qt-class-cpp-1"><a href="#Qt-class-cpp-1" class="headerlink" title="Qt class.cpp"></a>Qt class.cpp</h3><p>#parse(“C File Header.h”)</p>
<p>#[[#include]]# “${HEADER_FILENAME}”</p>
<h1 id="二-笔记"><a href="#二-笔记" class="headerlink" title="二.笔记"></a>二.笔记</h1><h2 id="1-中文乱码"><a href="#1-中文乱码" class="headerlink" title="1.中文乱码"></a>1.中文乱码</h2><p>1.全部改为utf-8编码，Qt5可以自动将utf-8编码转换为Unicode字符集<br>2.若编码为GBK,则可添加以下代码：<br>&#x2F;&#x2F;通过QTextCodec实现编码转换,创建编码对象<br>    QTextCodec *codec &#x3D; QTextCodec::codecForName(“GBK”);<br>&#x2F;&#x2F;在指定输出的字符前，对其进行转换<br>    QLabel label(codec-&gt;toUnicode(“我是标签”));</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*代码*/</span><br><span class="line">#include &lt;QApplication&gt;</span><br><span class="line">#include &lt;QLabel&gt;</span><br><span class="line">#include &lt;QPushButton&gt;</span><br><span class="line">#include &lt;QTextCodec&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[]) &#123;//arg参数 c命令行变量数量，v[]命令行变量的数组</span><br><span class="line">    //通过QTextCodec实现编码转换,创建编码对象</span><br><span class="line">    QTextCodec *codec = QTextCodec::codecForName(&quot;GBK&quot;);</span><br><span class="line">    //创建Qt应用程序对象</span><br><span class="line">    QApplication app(argc, argv);</span><br><span class="line">    //创建标签控件（图形对象）</span><br><span class="line">//    QLabel label(&quot;我是标签&quot;);//utf-8</span><br><span class="line">    QLabel label(codec-&gt;toUnicode(&quot;我是标签&quot;));</span><br><span class="line">    label.resize(400, 400);</span><br><span class="line"></span><br><span class="line">//    QPushButton button(&quot;我是按钮&quot;);//utf-8</span><br><span class="line">    QPushButton button(codec-&gt;toUnicode(&quot;我是按钮&quot;));</span><br><span class="line">    button.resize(200, 200);</span><br><span class="line"></span><br><span class="line">button.show();</span><br><span class="line">//显示标签控件</span><br><span class="line">label.show();</span><br><span class="line">//让应用程序进入事件循环</span><br><span class="line">return QApplication::exec();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-父窗口"><a href="#2-父窗口" class="headerlink" title="2.父窗口"></a>2.父窗口</h2><p>1.QWidget 所有用户界面对象的基类<br>2.QMainWindow(QWidget子类) 对话框窗口的基类<br>3.QDialog(QWidget子类) 提供一个有菜单条、工具栏、状态条的主应用程序窗口</p>
<ul>
<li>&#96;&#96;&#96;</li>
</ul>
<pre><code>/*代码*/
#include &lt;QWidget&gt;
#include &lt;QLabel&gt;
#include &lt;QPushButton&gt;
#include &lt;QApplication&gt;
</code></pre>
<p>  int main(int argc, char *argv[]) {<br>      QApplication app(argc, argv);<br>      QWidget w;<br>      &#x2F;<em>在栈区创建，编译器会自行销毁</em>&#x2F;<br>      &#x2F;&#x2F;创建标签控件，并停靠在父窗口<br>      QLabel label(“我是标签”, &amp;w);<br>      label.move(20, 40);<br>      label.show();<br>      &#x2F;&#x2F;创建按钮控件，并停靠在父窗口<br>      QPushButton button(“按钮”, &amp;w);<br>      button.move(50, 60);<br>      button.show();<br>      &#x2F;*在堆区创建，不需要且没有合适位置使用delete关键字进行销毁。Qt的父窗口对象销毁时，相关控件会自行销毁，</p>
<pre><code> * 因此不需要担心内存泄露问题*/
   //    QPushButton* button1 = new QPushButton(&quot;大按钮&quot;,&amp;w);
       auto button1 = new QPushButton(&quot;大按钮&quot;, &amp;w);
       button1-&gt;move(200, 60);
       button1-&gt;show();
       w.move(200, 100);
       w.resize(500, 300);
       w.show();
       return QApplication::exec();
   &#125;
</code></pre>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">## 3.信号和槽</span><br><span class="line"></span><br><span class="line">### 1.信号定义</span><br><span class="line"></span><br><span class="line">​    class XX:public QObject&#123;</span><br><span class="line">​        Q_OBJECT</span><br><span class="line">​    signals:</span><br><span class="line">​        void signal_func(...);//信号函数</span><br><span class="line">​    &#125;;</span><br><span class="line">​    注：信号函数只需写声明，不能写定义</span><br><span class="line"></span><br><span class="line">### 2.槽定义</span><br><span class="line"></span><br><span class="line">​    class XX:public QObject&#123;</span><br><span class="line">​            Q_OBJECT</span><br><span class="line">​    public slots:</span><br><span class="line">​        void slot_func(...);//信号函数</span><br><span class="line">​    &#125;;</span><br><span class="line">​    注：</span><br><span class="line">​    a.槽函数可以连接到某个信号上，当信号被发射时，槽函数将被触发和执行</span><br><span class="line">​    b.槽函数也可当作普通的成员函数直接调用</span><br><span class="line"></span><br><span class="line">### 3.信号和槽连接</span><br><span class="line"></span><br><span class="line">QObject::connect(const QObject* sender,const char* signal,</span><br><span class="line">                const QObject* receiver,const char* method);</span><br><span class="line">参数：</span><br><span class="line">    sender：信号发送对象指针</span><br><span class="line">    signal：要发送的信号函数，可以使用“SIGNAL(...)”宏进行类型转换</span><br><span class="line">    receiver：信号的接收对象指针</span><br><span class="line">    method：接收信号后要执行的槽函数，可以使用“SLOT(...)”宏进行类型转换</span><br><span class="line">语法：</span><br><span class="line">1.信号和槽函数参数要一致</span><br><span class="line">2.可带有缺省参数（比如int x=0）</span><br><span class="line">3.信号函数的参数可以多于槽函数</span><br><span class="line">应用：</span><br><span class="line">1.一对多：执行顺序不确定，需要看系统的调度策略</span><br><span class="line">    QObject::connect(A,SIGNAL(signfun(int)),B1,SLOT(slotfun1(int)));</span><br><span class="line">    QObject::connect(A,SIGNAL(signfun(int)),B2,SLOT(slotfun2(int)));</span><br><span class="line">2.多对一</span><br><span class="line">    QObject::connect(A1,SIGNAL(signfun1(int)),B,SLOT(slotfun(int)));</span><br><span class="line">    QObject::connect(A2,SIGNAL(signfun2(int)),B,SLOT(slotfun(int)));</span><br><span class="line">3.信号级联（不常用，了解即可）</span><br><span class="line">    QObject::connect(A,SIGNAL(signfun(int)),B,SLOT(slotfun(int)));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&#x2F;<em>代码</em>&#x2F;<br>a.<br>&#x2F;&#x2F;信号和槽—点击按钮关闭标签<br>    &#x2F;&#x2F;QObject::connect(按钮指针，按钮信号，标签指针，标签信号)，SIGNAL和SLOT可以将字符串转化为const char*<br>    QObject::connect(&amp;button, SIGNAL(clicked()),&amp;label, SLOT(close()));<br>&#x2F;&#x2F;信号和槽—增加一个退出按钮，点击后退出应用程序<br>    QPushButton exit(“退出”,&amp;w);<br>    exit.move(150,60);<br>    exit.show();<br>    QObject::connect(&amp;exit,SIGNAL(clicked()),<br>                    &#x2F;<em>在本程序中有三种方式可供关闭应用程序</em>&#x2F;<br>&#x2F;&#x2F;                     &amp;app, SLOT(closeAllWindows()));<br>                     &amp;app, SLOT(quit()));<br>                    &#x2F;&#x2F;当父窗口被关闭了，其包含的所有控件都会被关闭，同时导致事件循环结束<br>&#x2F;&#x2F;                     &amp;w, SLOT(close()));</p>
<p>b.通过信号和槽来实现滑块和取值框的同步<br>#include <QWidget><br>#include <QSlider><br>#include <QSpinBox><br>#include <QApplication></QApplication></QSpinBox></QSlider></QWidget></p>
<p>int main(int argc, char *argv[]) {<br>    QApplication app(argc, argv);<br>    &#x2F;&#x2F;创建父窗口<br>    QWidget parent;<br>    parent.resize(400, 300);<br>    parent.show();<br>    &#x2F;&#x2F;创建水平滑块,水平的：Horizontal，垂直的：Vertical<br>    QSlider slider(Qt::Horizontal, &amp;parent);<br>    slider.move(50, 100);<br>    slider.resize(100, 50);<br>    &#x2F;&#x2F;设置取值范围<br>    slider.setRange(0, 999);<br>    slider.show();<br>    &#x2F;&#x2F;创建选值框<br>    QSpinBox spinBox(&amp;parent);<br>    spinBox.move(250, 100);<br>    spinBox.resize(100, 50);<br>    &#x2F;&#x2F;设置取值范围<br>    spinBox.setRange(0, 999);<br>    spinBox.show();<br>    &#x2F;&#x2F;块动值动<br>    QObject::connect(&amp;slider, SIGNAL(valueChanged(int)), &amp;spinBox, SLOT(setValue(int)));<br>    &#x2F;&#x2F;值动块动<br>    QObject::connect(&amp;spinBox, SIGNAL(valueChanged(int)), &amp;slider, SLOT(setValue(int)));<br>    return QApplication::exec();<br>}</p>
<h1 id="三-Qt事件处理机制"><a href="#三-Qt事件处理机制" class="headerlink" title="三.Qt事件处理机制"></a>三.Qt事件处理机制</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h2><h3 id="1-1什么是事件？"><a href="#1-1什么是事件？" class="headerlink" title="1.1什么是事件？"></a>1.1什么是事件？</h3><p><img src="img_0.png"></p>
<h3 id="1-2如何处理事件？"><a href="#1-2如何处理事件？" class="headerlink" title="1.2如何处理事件？"></a>1.2如何处理事件？</h3><p><img src="img_1.png"></p>
<h3 id="1-3如何重写事件？"><a href="#1-3如何重写事件？" class="headerlink" title="1.3如何重写事件？"></a>1.3如何重写事件？</h3><p><img src="img_2.png"></p>
<h2 id="2-分类"><a href="#2-分类" class="headerlink" title="2.分类"></a>2.分类</h2><h3 id="2-1绘图事件"><a href="#2-1绘图事件" class="headerlink" title="2.1绘图事件"></a>2.1绘图事件</h3><h4 id="2-1-1概念"><a href="#2-1-1概念" class="headerlink" title="2.1.1概念"></a>2.1.1概念</h4><p><img src="img_3.png"></p>
<h4 id="2-1-2具体操作流程"><a href="#2-1-2具体操作流程" class="headerlink" title="2.1.2具体操作流程"></a>2.1.2具体操作流程</h4><h5 id="图片存放"><a href="#图片存放" class="headerlink" title="-图片存放-"></a>-图片存放-</h5><p>a.在项目根目录创建images文件夹用于存放需要用到的图片，建议格式统一eg:1.jpg，2.jpg，目的是方便利用Index索引调用图片。</p>
<p>b.除此之外，还应创建一个.qrc文件，qrc是Qt的资源文件，格式模板如下：</p>
<p>prefix表示前缀</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;RCC&gt;</span><br><span class="line">    &lt;qresource prefix=&quot;&quot;&gt;</span><br><span class="line">        &lt;file&gt;&lt;/file&gt;</span><br><span class="line">    &lt;/qresource&gt;</span><br><span class="line">&lt;/RCC&gt;</span><br></pre></td></tr></table></figure>

<h5 id="图标设置和自定义"><a href="#图标设置和自定义" class="headerlink" title="-图标设置和自定义-"></a>-图标设置和自定义-</h5><p>a.需要准备一个图标，将其命名为logo.ico或者自定义名.ico，如果没有图标文件，可以在这个网站进行图片到图标的转换：</p>
<p>PNG转ICO - 在线转换图标文件：<a href="https://www.aconvert.com/cn/icon/png-to-ico/%EF%BC%88ctrl+%E9%BC%A0%E6%A0%87%E5%B7%A6%E9%94%AE%E7%82%B9%E5%87%BB%E8%AE%BF%E9%97%AE%EF%BC%89">https://www.aconvert.com/cn/icon/png-to-ico/（ctrl+鼠标左键点击访问）</a></p>
<p>b.需要一个.rc文件，模板如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id ICON</span><br><span class="line">&quot;logo.ico&quot;   //添加图标</span><br><span class="line">#include &lt;winver.h&gt;</span><br><span class="line"></span><br><span class="line">VS_VERSION_INFO</span><br><span class="line">VERSIONINFO</span><br><span class="line">        FILEVERSION</span><br><span class="line">1,0,0,10</span><br><span class="line">PRODUCTVERSION 1,0,0,10</span><br><span class="line">FILEFLAGSMASK 0x3fL</span><br><span class="line">#ifdef _DEBUG</span><br><span class="line">FILEFLAGS VS_FF_DEBUG</span><br><span class="line">#endif</span><br><span class="line">FILEOS VOS__WINDOWS32</span><br><span class="line">FILETYPE VFT_DLL</span><br><span class="line">FILESUBTYPE 0x0L</span><br><span class="line">BEGIN</span><br><span class="line">        BLOCK</span><br><span class="line">&quot;StringFileInfo&quot;</span><br><span class="line">BEGIN</span><br><span class="line">        BLOCK</span><br><span class="line">&quot;080404b0&quot;  //支持中文</span><br><span class="line">BEGIN</span><br><span class="line">/*文件说明*/ VALUE</span><br><span class="line">&quot;CompanyName&quot;, &quot;PgmTop有限公司\0&quot;</span><br><span class="line">/*文件说明*/ VALUE &quot;FileDescription&quot;, &quot;一款用于查看存放好的图片的简易浏览器\0&quot;</span><br><span class="line">/*文件版本*/ VALUE &quot;ProductName&quot;, &quot;图片浏览器\0&quot;</span><br><span class="line">/*产品名称*/ VALUE &quot;FileVersion&quot;, &quot;1.0\0&quot;</span><br><span class="line">/*产品版本*/ VALUE &quot;ProductVersion&quot;, &quot;1.0\0&quot;</span><br><span class="line">/*版权*/ VALUE &quot;LegalCopyright&quot;, &quot;版权所有 (C) PgmTop有限公司\0&quot;</span><br><span class="line">/*合法商标*/ VALUE &quot;LegalTrademarks&quot;, &quot;PgmTop有限公司\0&quot;</span><br><span class="line">/*原始文件名*/ VALUE &quot;OriginalFilename&quot;, &quot;demo.exe\0&quot;</span><br><span class="line">/*内部文件名*/ VALUE &quot;InternalName&quot;, &quot;demo.exe\0&quot;</span><br><span class="line">END</span><br><span class="line">        END</span><br><span class="line"></span><br><span class="line">BLOCK &quot;VarFileInfo&quot;</span><br><span class="line">BEGIN</span><br><span class="line">        VALUE</span><br><span class="line">&quot;Translation&quot;, 0x804, 1200  //语言-简体中文</span><br><span class="line">END</span><br><span class="line">        END</span><br></pre></td></tr></table></figure>

<p>c.只完成ab两步，生成的exe文件描述会有乱码，这是编码的问题。.rc文件默认utf-8编码，直接将其在Notepad++中选择左上方编码，然后转为ANSI编码即可。</p>
<p>d.通过a和b我们已经设置好了应用图标，但是生成的QApplication应用仍然是无图标状态，可以通过以下代码进行设置</p>
<p><strong>.&#x2F;:当前项目目录</strong></p>
<p><strong>..&#x2F;:上一级的项目目录</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;QIcon&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">si.setWindowIcon(QIcon(&quot;../xxx/xxx.ico&quot;));</span><br></pre></td></tr></table></figure>

<h5 id="注意事项"><a href="#注意事项" class="headerlink" title="-注意事项-"></a>-注意事项-</h5><p>a.不要忘记将.qrc和.rc文件添加到CMakeLists.txt的add_executable()中去。</p>
<p>b.出现问题：</p>
<p>在将生成的exe文件封装打包后，点击运行生成的QApplication应用仍存在无图标，只有在构建运行的环境下才能正常显示。</p>
<p><strong>解决方案及原因：</strong></p>
<p>​	<strong>原因：</strong>这是因为在clion编程环境中，工作目录为cmake-build-debug，所有的.exe文件会在该目录下生成。所以在不改变我们的工作目</p>
<p>录情况下，我们采用了这种方式*<code>si.setWindowIcon(QIcon(&quot;../xxx/xxx.ico&quot;));</code>*，也就是从工作目录返回到项目目录，在项目目录下</p>
<p>查找我们自己创建的目录下的文件。</p>
<p>​	<strong>解决方案：</strong><code>si.setWindowIcon(QIcon(&quot;./xxx/xxx.ico&quot;));</code>将**..&#x2F;<strong>换为</strong>.&#x2F;**,并在已经封装好的.exe文件目录下创建文件夹xxx&#x2F;xxx.ico，</p>
<p>这样我们就能在生成的QApplication下看到我们设置的图标啦！</p>
<h5 id="效果展示"><a href="#效果展示" class="headerlink" title="-效果展示-"></a>-效果展示-</h5><p><strong>应用图标及信息</strong></p>
<p><img src="icon_0.png"></p>
<p><img src="icon_1.png"></p>
<p><strong>程序输出窗口</strong></p>
<p><img src="icon_2.png"></p>
<p><strong>QApplication窗口图标</strong></p>
<p><img src="icon_3.png" alt="十三点"></p>
<h3 id="2-2定时器事件"><a href="#2-2定时器事件" class="headerlink" title="2.2定时器事件"></a>2.2定时器事件</h3><p><img src="img_4.png"></p>
<h3 id="2-3鼠标和键盘事件"><a href="#2-3鼠标和键盘事件" class="headerlink" title="2.3鼠标和键盘事件"></a>2.3鼠标和键盘事件</h3>]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>C++,Qt</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2022/08/29/%E4%B9%A0%E9%A2%98/</url>
    <content><![CDATA[<h1 id="练习题"><a href="#练习题" class="headerlink" title="练习题"></a>练习题</h1><h2 id="1-删除顺序表中最小值"><a href="#1-删除顺序表中最小值" class="headerlink" title="1.删除顺序表中最小值"></a>1.删除顺序表中最小值</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*删除顺序表中最小值*/</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int deleteMin(int *arr, int len) &#123;</span><br><span class="line">    if (arr == nullptr || len == 0) &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">    int minIndex = 0;</span><br><span class="line">    for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        minIndex = arr[minIndex] &lt; arr[i] ? minIndex : i;</span><br><span class="line">    &#125;</span><br><span class="line">    int result = arr[minIndex];</span><br><span class="line">    *(arr + minIndex) = *(arr + len - 1);</span><br><span class="line">    *(arr + len - 1) = 0;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int len;</span><br><span class="line">    int *arr = new int[len];</span><br><span class="line">    cout &lt;&lt; &quot;输入数组的长度：&quot;;</span><br><span class="line">    cin &gt;&gt; len;</span><br><span class="line">    for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; deleteMin(arr, len) &lt;&lt; endl;</span><br><span class="line">    for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-双指针反转数组"><a href="#2-双指针反转数组" class="headerlink" title="2.双指针反转数组"></a>2.双指针反转数组</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*双指针反转数组*/</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void reverseList(int *arr, int len) &#123;</span><br><span class="line">    int begin = 0;</span><br><span class="line">    int end = len - 1;</span><br><span class="line">    for (int i = 0; i &lt; len / 2; i++) &#123;</span><br><span class="line">        int temp = arr[begin];</span><br><span class="line">        arr[begin++] = arr[end];</span><br><span class="line">        arr[end--] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int len = 0;</span><br><span class="line">    int *arr = new int[len];</span><br><span class="line">    cout &lt;&lt; &quot;输入数组的长度：&quot;;</span><br><span class="line">    cin &gt;&gt; len;</span><br><span class="line">    for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        cin &gt;&gt; arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    reverseList(arr, len);</span><br><span class="line">    for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="image-20220829172226058.png" alt="image-20220829172226058"></p>
<h2 id="3-删除数组指定值"><a href="#3-删除数组指定值" class="headerlink" title="3.删除数组指定值"></a>3.删除数组指定值</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*删除数组指定值*/</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void deleteValue(int *arr, int len, int value) &#123;</span><br><span class="line">    int temp = 0;</span><br><span class="line">    int index = 0;</span><br><span class="line">    while (index &lt; len) &#123;</span><br><span class="line">        if (*(arr + index) == value) &#123;</span><br><span class="line">            temp++; //temp即是与value相对的数的数量，也是其他与value不相等的数需要移动的次数</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            *(arr + index - temp) = *(arr + index);</span><br><span class="line">        &#125;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">    //与value不相等的数迁移后，就将多余的数置零</span><br><span class="line">    for (int i = 0; i &lt; temp; i++) &#123;</span><br><span class="line">        *(arr + len - 1 - i) = 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void show(int *arr, int len) &#123;</span><br><span class="line">    for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">    int arr[] = &#123;1, 2, 3, 5, 2, 2, 2&#125;;</span><br><span class="line">    int len = sizeof(arr) / sizeof(int);</span><br><span class="line">    show(arr, len);</span><br><span class="line">    deleteValue(arr, len, 2);</span><br><span class="line">    show(arr, len);</span><br><span class="line">    system(&quot;pause&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="image-20220829175408267.png" alt="image-20220829175408267"></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2022/08/27/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<h1 id="王道考研-数据结构笔记"><a href="#王道考研-数据结构笔记" class="headerlink" title="王道考研-数据结构笔记"></a>王道考研-数据结构笔记</h1><h2 id="一-关于-amp-的使用，它会返回修改的结果"><a href="#一-关于-amp-的使用，它会返回修改的结果" class="headerlink" title="一.关于&amp;的使用，它会返回修改的结果"></a>一.关于&amp;的使用，它会返回修改的结果</h2><p>代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test1</span><span class="params">(<span class="type">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">	x = <span class="number">1024</span>;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;test1: &quot;</span>&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">	x = <span class="number">1024</span>;</span><br><span class="line">	cout&lt;&lt;<span class="string">&quot;test: &quot;</span>&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> x = <span class="number">1</span>;</span><br><span class="line">	cout&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">	<span class="comment">//test(x);</span></span><br><span class="line">	<span class="built_in">test1</span>(x);</span><br><span class="line">	cout&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">	<span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="image-20220828222517653.png" alt="image-20220828222517653"></p>
<p><img src="image-20220828222630571.png" alt="image-20220828222630571"></p>
<h2 id="二-顺序表的定义"><a href="#二-顺序表的定义" class="headerlink" title="二.顺序表的定义"></a>二.顺序表的定义</h2><h3 id="2-1静态分配顺序表"><a href="#2-1静态分配顺序表" class="headerlink" title="2.1静态分配顺序表"></a>2.1静态分配顺序表</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MaxSize 10 <span class="comment">//定义最大长度</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">	<span class="type">int</span> data[MaxSize]; <span class="comment">//定义一个静态数组存放数据元素</span></span><br><span class="line">	<span class="type">int</span> length; <span class="comment">//顺序表当前长度</span></span><br><span class="line">&#125;Seqlist; <span class="comment">//顺序表类型定义</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//基本操作-初始化一个顺序表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitList</span><span class="params">(Seqlist &amp;l)</span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;MaxSize;i++)&#123;</span><br><span class="line">		l.data[i]=<span class="number">0</span>; <span class="comment">//将所有数据元素设置为0</span></span><br><span class="line">	&#125;</span><br><span class="line">	l.length=<span class="number">0</span>; <span class="comment">//设置顺序表初始长度为0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">	Seqlist l;</span><br><span class="line">	InitList(l);</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;MaxSize;i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,l.data[i]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="2-2动态分配顺序表"><a href="#2-2动态分配顺序表" class="headerlink" title="2.2动态分配顺序表"></a>2.2动态分配顺序表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#define InitSize 10 </span><br><span class="line"></span><br><span class="line">typedef struct&#123;</span><br><span class="line">	int *data; //指示动态分配数组的指针</span><br><span class="line">	int MaxSize;</span><br><span class="line">	int length; //顺序表当前长度</span><br><span class="line">&#125;Seqlist; //顺序表类型定义</span><br><span class="line"></span><br><span class="line">//基本操作-初始化一个顺序表</span><br><span class="line">void InitList(Seqlist &amp;l)&#123;</span><br><span class="line">	l.data=(int *)malloc(InitSize * sizeof(int));</span><br><span class="line">	l.length=0; //设置顺序表初始长度为0</span><br><span class="line">	l.MaxSize=InitSize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void IncreaseSize(Seqlist &amp;l,int len)&#123;</span><br><span class="line">	int *p=l.data;</span><br><span class="line">	l.data=(int *)malloc((l.MaxSize+len) * sizeof(int));</span><br><span class="line">	for(int i=0;i&lt;l.length;i++)&#123;</span><br><span class="line">		l.data[i]=p[i];</span><br><span class="line">	&#125;</span><br><span class="line">	l.MaxSize = l.MaxSize+len;</span><br><span class="line">	free(p);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	Seqlist l;</span><br><span class="line">	InitList(l);</span><br><span class="line">	IncreaseSize(l,5);</span><br><span class="line">	printf(&quot;%d\n&quot;,l.MaxSize);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="image-20220829134945636.png" alt="image-20220829134945636"></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2022/09/02/%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h1><h2 id="1-Fibornacci"><a href="#1-Fibornacci" class="headerlink" title="1.Fibornacci"></a>1.Fibornacci</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*暴力递归---时间复杂度为O(2^n)*/</span><br><span class="line">int fib(int num) &#123;</span><br><span class="line">    if (num == 1 || num == 2) return 1;</span><br><span class="line">    return fib(num - 1) + fib(num - 2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*自顶向下的递归解法---时间复杂度为O(n)*/</span><br><span class="line">int help(vector&lt;int&gt; &amp;memo, int n) &#123;</span><br><span class="line">    if (n == 1 || n == 2) return 1;</span><br><span class="line">    //在自顶向下递归过程已经算出memo[n]的值，并将其输出</span><br><span class="line">    if (memo[n] != 0) return memo[n];</span><br><span class="line">    //自顶向下的递归，并将子递归结果返回</span><br><span class="line">    memo[n] = help(memo, n - 1) + help(memo, n - 2);</span><br><span class="line">    return memo[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int fib2(int num) &#123;</span><br><span class="line">    if (num &lt; 1) return 0;</span><br><span class="line">    vector&lt;int&gt; memo(num + 1, 0);    //备忘录初始化</span><br><span class="line">    return help(memo, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*自底向上的dpTable---时间复杂度为O(n)*/</span><br><span class="line">int fib3(int num) &#123;</span><br><span class="line">    vector&lt;int&gt; dp(num + 1, 0);</span><br><span class="line">    dp[1] = dp[2] = 1;</span><br><span class="line">    for (int i = 3; i &lt;= num; i++) &#123;</span><br><span class="line">        dp[i] = dp[i - 1] + dp[i - 2];</span><br><span class="line">    &#125;</span><br><span class="line">    return dp[num];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/*fib3的优化，只保留前两个状态*/</span><br><span class="line">int fib4(int num) &#123;</span><br><span class="line">    if (num == 1 || num == 2) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    int prev = 1, curr = 1;</span><br><span class="line">    for (int i = 3; i &lt;= num; i++) &#123;</span><br><span class="line">        int sum = prev + curr;</span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    return curr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="2-Longest-Increment-Subsequence"><a href="#2-Longest-Increment-Subsequence" class="headerlink" title="2.Longest Increment Subsequence"></a>2.Longest Increment Subsequence</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">//求最长递增子序列</span><br><span class="line">int lengthOfLIS(vector&lt;int&gt; nums) &#123;</span><br><span class="line">    vector&lt;int&gt; dp(nums.size(), 1); //子序列肯定包括自己，将其全部初始化为1</span><br><span class="line">    //求出dp数组</span><br><span class="line">    for (int i = 0; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        cout &lt;&lt; &quot;nums[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot; &lt;&lt; nums[i] &lt;&lt; &quot;, &quot;;</span><br><span class="line">        for (int j = 0; j &lt; i; j++) &#123;</span><br><span class="line">            if (nums[j] &lt; nums[i]) &#123;</span><br><span class="line">//                dp[i] = dp[j] + 1;</span><br><span class="line">                dp[i] = max(dp[i], dp[j] + 1); //可能会有多个子序列，取最长的那一个序列放到dp数组中</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; &quot;dp[&quot; &lt;&lt; i &lt;&lt; &quot;] = &quot; &lt;&lt; dp[i] &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int res = 0;</span><br><span class="line">    for (int i = 0; i &lt; dp.size(); i++) &#123;</span><br><span class="line">        res = max(res, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void test01() &#123;</span><br><span class="line">    vector&lt;int&gt; nums = &#123;1, 4, 3, 4, 5, 2, 3&#125;;</span><br><span class="line">    int res = lengthOfLIS(nums);</span><br><span class="line">    cout &lt;&lt; res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line"></span><br><span class="line">    test01();</span><br><span class="line"></span><br><span class="line">//    system(&quot;pause&quot;);</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-isPrime"><a href="#3-isPrime" class="headerlink" title="3.isPrime?"></a>3.isPrime?</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">#include&lt;cmath&gt; //sqrt()的头文件</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void isPrime(int n);</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int N = 0;</span><br><span class="line">	cin &gt;&gt; N;</span><br><span class="line">	for (int i = 2; i &lt;= N; i++) &#123;</span><br><span class="line">		isPrime(i);</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void isPrime(int n) &#123;</span><br><span class="line">	int sqare = sqrt(n);</span><br><span class="line">	bool flag = true;</span><br><span class="line">	//使用平方根对数据进行简化后，i应该是&lt;=sqare，否则会出错</span><br><span class="line">	for (int i = 2; i &lt;= sqare; i++) &#123;</span><br><span class="line">		if (n % i == 0) &#123;</span><br><span class="line">			flag = false;</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if (flag) &#123;</span><br><span class="line">		cout &lt;&lt; n &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2022/08/26/%E8%8B%B1%E8%AF%AD%E5%9B%9B%E7%BA%A7/</url>
    <content><![CDATA[<h1 id="英语四级"><a href="#英语四级" class="headerlink" title="英语四级"></a>英语四级</h1><h1 id="一-分值分布"><a href="#一-分值分布" class="headerlink" title="一.分值分布"></a>一.分值分布</h1><h2 id="1-写作-106-5分-15"><a href="#1-写作-106-5分-15" class="headerlink" title="1.写作 106.5分 15%"></a>1.写作 106.5分 15%</h2><h2 id="2-听力-248-5分-35"><a href="#2-听力-248-5分-35" class="headerlink" title="2.听力 248.5分 35%"></a>2.听力 248.5分 35%</h2><p>2.1A：新闻 7.1分&#x2F;题  *7</p>
<p>2.2B：长对话 7.1分&#x2F;题  *8</p>
<p>2.3C：文章 14.2分&#x2F;题  *10</p>
<h2 id="3-阅读理解-248-5分-35"><a href="#3-阅读理解-248-5分-35" class="headerlink" title="3.阅读理解 248.5分 35%"></a>3.阅读理解 248.5分 35%</h2><p>3.1A：选词填空 3.55分&#x2F;题  *10</p>
<p>3.2B：长篇阅读 7.1分&#x2F;题  *10</p>
<p>3.3C：仔细阅读 14.2分&#x2F;题  *10</p>
<h2 id="4-汉译英-106-5分-15"><a href="#4-汉译英-106-5分-15" class="headerlink" title="4.汉译英 106.5分 15%"></a>4.汉译英 106.5分 15%</h2><h1 id="二-成绩统计"><a href="#二-成绩统计" class="headerlink" title="二.成绩统计"></a>二.成绩统计</h1><h1 id="三-做题策略"><a href="#三-做题策略" class="headerlink" title="三.做题策略"></a>三.做题策略</h1><h1 id="四-作文总结"><a href="#四-作文总结" class="headerlink" title="四.作文总结"></a>四.作文总结</h1><h1 id="五-翻译总结"><a href="#五-翻译总结" class="headerlink" title="五.翻译总结"></a>五.翻译总结</h1><h2 id="5-1翻译思路"><a href="#5-1翻译思路" class="headerlink" title="5.1翻译思路"></a>5.1翻译思路</h2><p>1.英语与汉语不同，不一定要按照给出的汉语的断句方式来断英语</p>
<p>2.忽略汉语的定语，找到句子本体。</p>
<h2 id="5-2语义替换"><a href="#5-2语义替换" class="headerlink" title="5.2语义替换"></a>5.2语义替换</h2><p> 1.被称为&#x3D;因…出名</p>
<p>known as…</p>
<h2 id="5-3单词替换"><a href="#5-3单词替换" class="headerlink" title="5.3单词替换"></a>5.3单词替换</h2><p>1.综合体；结合体</p>
<p>combination&#x3D;synthesis</p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2022/08/27/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
