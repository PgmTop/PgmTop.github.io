<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Qt图形库-学习笔记</title>
    <url>/2022/08/17/QtNode/</url>
    <content><![CDATA[<h1 id="一-Clion中创建Qt类的相关模板"><a href="#一-Clion中创建Qt类的相关模板" class="headerlink" title="一.Clion中创建Qt类的相关模板"></a>一.Clion中创建Qt类的相关模板</h1><h2 id="1-原模板："><a href="#1-原模板：" class="headerlink" title="1.原模板："></a>1.原模板：</h2><h3 id="Qt-Class-Header-h"><a href="#Qt-Class-Header-h" class="headerlink" title="Qt Class Header.h"></a>Qt Class Header.h</h3><p>#parse(“C File Header.h”)<br>#[[#ifndef]]# ${INCLUDE_GUARD}<br>#[[#define]]# ${INCLUDE_GUARD}</p>
<p>#[[#include]]# &lt;${PARENT_CLASS}&gt;</p>
<p>${USER_BEGIN_NAMESPACE}<br>QT_BEGIN_NAMESPACE<br>namespace Ui { class ${NAME}; }<br>QT_END_NAMESPACE</p>
<p>class ${NAME} : public ${PARENT_CLASS} {<br>Q_OBJECT</p>
<p>public:<br>    explicit ${NAME}(QWidget *parent &#x3D; nullptr);<br>    ~${NAME}() override;</p>
<p>private:<br>    Ui::${NAME} *ui;<br>};<br>${USER_END_NAMESPACE}</p>
<p>#[[#endif]]# &#x2F;&#x2F;${INCLUDE_GUARD}</p>
<h3 id="Qt-class-cpp"><a href="#Qt-class-cpp" class="headerlink" title="Qt class.cpp"></a>Qt class.cpp</h3><p>#parse(“C File Header.h”)<br>&#x2F;&#x2F; You may need to build the project (run Qt uic code generator) to get “${UI_HEADER_FILENAME}” resolved</p>
<p>#[[#include]]# “${HEADER_FILENAME}”<br>#[[#include]]# “${UI_HEADER_FILENAME}”</p>
<p>${USER_BEGIN_NAMESPACE}<br>${NAME}::${NAME}(QWidget *parent) :<br>    ${PARENT_CLASS}(parent), ui(new Ui::${NAME}) {<br>    ui-&gt;setupUi(this);<br>}</p>
<p>${NAME}::~${NAME}() {<br>    delete ui;<br>}<br>${USER_END_NAMESPACE}&#96;</p>
<h2 id="2-自用模板："><a href="#2-自用模板：" class="headerlink" title="2.自用模板："></a>2.自用模板：</h2><h3 id="Qt-Class-Header-h-1"><a href="#Qt-Class-Header-h-1" class="headerlink" title="Qt Class Header.h"></a>Qt Class Header.h</h3><p>#parse(“C File Header.h”)</p>
<p>#[[#ifndef]]# ${INCLUDE_GUARD}<br>#[[#define]]# ${INCLUDE_GUARD}</p>
<p>#[[#include]]# &lt;${PARENT_CLASS}&gt;<br>#[[#include]]# “${UI_HEADER_FILENAME}”</p>
<p>class ${NAME} : public ${PARENT_CLASS} {</p>
<p>};</p>
<p>#[[#endif]]# &#x2F;&#x2F;${INCLUDE_GUARD}</p>
<h3 id="Qt-class-cpp-1"><a href="#Qt-class-cpp-1" class="headerlink" title="Qt class.cpp"></a>Qt class.cpp</h3><p>#parse(“C File Header.h”)</p>
<p>#[[#include]]# “${HEADER_FILENAME}”</p>
<h1 id="二-笔记"><a href="#二-笔记" class="headerlink" title="二.笔记"></a>二.笔记</h1><h2 id="1-中文乱码"><a href="#1-中文乱码" class="headerlink" title="1.中文乱码"></a>1.中文乱码</h2><p>1.全部改为utf-8编码，Qt5可以自动将utf-8编码转换为Unicode字符集<br>2.若编码为GBK,则可添加以下代码：<br>&#x2F;&#x2F;通过QTextCodec实现编码转换,创建编码对象<br>    QTextCodec *codec &#x3D; QTextCodec::codecForName(“GBK”);<br>&#x2F;&#x2F;在指定输出的字符前，对其进行转换<br>    QLabel label(codec-&gt;toUnicode(“我是标签”));</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*代码*/</span><br><span class="line">#include &lt;QApplication&gt;</span><br><span class="line">#include &lt;QLabel&gt;</span><br><span class="line">#include &lt;QPushButton&gt;</span><br><span class="line">#include &lt;QTextCodec&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[]) &#123;//arg参数 c命令行变量数量，v[]命令行变量的数组</span><br><span class="line">    //通过QTextCodec实现编码转换,创建编码对象</span><br><span class="line">    QTextCodec *codec = QTextCodec::codecForName(&quot;GBK&quot;);</span><br><span class="line">    //创建Qt应用程序对象</span><br><span class="line">    QApplication app(argc, argv);</span><br><span class="line">    //创建标签控件（图形对象）</span><br><span class="line">//    QLabel label(&quot;我是标签&quot;);//utf-8</span><br><span class="line">    QLabel label(codec-&gt;toUnicode(&quot;我是标签&quot;));</span><br><span class="line">    label.resize(400, 400);</span><br><span class="line"></span><br><span class="line">//    QPushButton button(&quot;我是按钮&quot;);//utf-8</span><br><span class="line">    QPushButton button(codec-&gt;toUnicode(&quot;我是按钮&quot;));</span><br><span class="line">    button.resize(200, 200);</span><br><span class="line"></span><br><span class="line">button.show();</span><br><span class="line">//显示标签控件</span><br><span class="line">label.show();</span><br><span class="line">//让应用程序进入事件循环</span><br><span class="line">return QApplication::exec();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-父窗口"><a href="#2-父窗口" class="headerlink" title="2.父窗口"></a>2.父窗口</h2><p>1.QWidget 所有用户界面对象的基类<br>2.QMainWindow(QWidget子类) 对话框窗口的基类<br>3.QDialog(QWidget子类) 提供一个有菜单条、工具栏、状态条的主应用程序窗口</p>
<ul>
<li>&#96;&#96;&#96;<br>&#x2F;<em>代码</em>&#x2F;<br>#include <QWidget><br>#include <QLabel><br>#include <QPushButton><br>#include <QApplication></QApplication></QPushButton></QLabel></QWidget></li>
</ul>
<p>  int main(int argc, char *argv[]) {<br>      QApplication app(argc, argv);<br>      QWidget w;<br>      &#x2F;<em>在栈区创建，编译器会自行销毁</em>&#x2F;<br>      &#x2F;&#x2F;创建标签控件，并停靠在父窗口<br>      QLabel label(“我是标签”, &amp;w);<br>      label.move(20, 40);<br>      label.show();<br>      &#x2F;&#x2F;创建按钮控件，并停靠在父窗口<br>      QPushButton button(“按钮”, &amp;w);<br>      button.move(50, 60);<br>      button.show();<br>      &#x2F;*在堆区创建，不需要且没有合适位置使用delete关键字进行销毁。Qt的父窗口对象销毁时，相关控件会自行销毁，</p>
<pre><code> * 因此不需要担心内存泄露问题*/
   //    QPushButton* button1 = new QPushButton(&quot;大按钮&quot;,&amp;w);
       auto button1 = new QPushButton(&quot;大按钮&quot;, &amp;w);
       button1-&gt;move(200, 60);
       button1-&gt;show();
       w.move(200, 100);
       w.resize(500, 300);
       w.show();
       return QApplication::exec();
   &#125;
</code></pre>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">## 3.信号和槽</span><br><span class="line"></span><br><span class="line">### 1.信号定义</span><br><span class="line"></span><br><span class="line">​    class XX:public QObject&#123;</span><br><span class="line">​        Q_OBJECT</span><br><span class="line">​    signals:</span><br><span class="line">​        void signal_func(...);//信号函数</span><br><span class="line">​    &#125;;</span><br><span class="line">​    注：信号函数只需写声明，不能写定义</span><br><span class="line"></span><br><span class="line">### 2.槽定义</span><br><span class="line"></span><br><span class="line">​    class XX:public QObject&#123;</span><br><span class="line">​            Q_OBJECT</span><br><span class="line">​    public slots:</span><br><span class="line">​        void slot_func(...);//信号函数</span><br><span class="line">​    &#125;;</span><br><span class="line">​    注：</span><br><span class="line">​    a.槽函数可以连接到某个信号上，当信号被发射时，槽函数将被触发和执行</span><br><span class="line">​    b.槽函数也可当作普通的成员函数直接调用</span><br><span class="line"></span><br><span class="line">### 3.信号和槽连接</span><br><span class="line"></span><br><span class="line">QObject::connect(const QObject* sender,const char* signal,</span><br><span class="line">                const QObject* receiver,const char* method);</span><br><span class="line">参数：</span><br><span class="line">    sender：信号发送对象指针</span><br><span class="line">    signal：要发送的信号函数，可以使用“SIGNAL(...)”宏进行类型转换</span><br><span class="line">    receiver：信号的接收对象指针</span><br><span class="line">    method：接收信号后要执行的槽函数，可以使用“SLOT(...)”宏进行类型转换</span><br><span class="line">语法：</span><br><span class="line">1.信号和槽函数参数要一致</span><br><span class="line">2.可带有缺省参数（比如int x=0）</span><br><span class="line">3.信号函数的参数可以多于槽函数</span><br><span class="line">应用：</span><br><span class="line">1.一对多：执行顺序不确定，需要看系统的调度策略</span><br><span class="line">    QObject::connect(A,SIGNAL(signfun(int)),B1,SLOT(slotfun1(int)));</span><br><span class="line">    QObject::connect(A,SIGNAL(signfun(int)),B2,SLOT(slotfun2(int)));</span><br><span class="line">2.多对一</span><br><span class="line">    QObject::connect(A1,SIGNAL(signfun1(int)),B,SLOT(slotfun(int)));</span><br><span class="line">    QObject::connect(A2,SIGNAL(signfun2(int)),B,SLOT(slotfun(int)));</span><br><span class="line">3.信号级联（不常用，了解即可）</span><br><span class="line">    QObject::connect(A,SIGNAL(signfun(int)),B,SLOT(slotfun(int)));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&#x2F;<em>代码</em>&#x2F;<br>a.<br>&#x2F;&#x2F;信号和槽—点击按钮关闭标签<br>    &#x2F;&#x2F;QObject::connect(按钮指针，按钮信号，标签指针，标签信号)，SIGNAL和SLOT可以将字符串转化为const char*<br>    QObject::connect(&amp;button, SIGNAL(clicked()),&amp;label, SLOT(close()));<br>&#x2F;&#x2F;信号和槽—增加一个退出按钮，点击后退出应用程序<br>    QPushButton exit(“退出”,&amp;w);<br>    exit.move(150,60);<br>    exit.show();<br>    QObject::connect(&amp;exit,SIGNAL(clicked()),<br>                    &#x2F;<em>在本程序中有三种方式可供关闭应用程序</em>&#x2F;<br>&#x2F;&#x2F;                     &amp;app, SLOT(closeAllWindows()));<br>                     &amp;app, SLOT(quit()));<br>                    &#x2F;&#x2F;当父窗口被关闭了，其包含的所有控件都会被关闭，同时导致事件循环结束<br>&#x2F;&#x2F;                     &amp;w, SLOT(close()));</p>
<p>b.通过信号和槽来实现滑块和取值框的同步<br>#include <QWidget><br>#include <QSlider><br>#include <QSpinBox><br>#include <QApplication></QApplication></QSpinBox></QSlider></QWidget></p>
<p>int main(int argc, char *argv[]) {<br>    QApplication app(argc, argv);<br>    &#x2F;&#x2F;创建父窗口<br>    QWidget parent;<br>    parent.resize(400, 300);<br>    parent.show();<br>    &#x2F;&#x2F;创建水平滑块,水平的：Horizontal，垂直的：Vertical<br>    QSlider slider(Qt::Horizontal, &amp;parent);<br>    slider.move(50, 100);<br>    slider.resize(100, 50);<br>    &#x2F;&#x2F;设置取值范围<br>    slider.setRange(0, 999);<br>    slider.show();<br>    &#x2F;&#x2F;创建选值框<br>    QSpinBox spinBox(&amp;parent);<br>    spinBox.move(250, 100);<br>    spinBox.resize(100, 50);<br>    &#x2F;&#x2F;设置取值范围<br>    spinBox.setRange(0, 999);<br>    spinBox.show();<br>    &#x2F;&#x2F;块动值动<br>    QObject::connect(&amp;slider, SIGNAL(valueChanged(int)), &amp;spinBox, SLOT(setValue(int)));<br>    &#x2F;&#x2F;值动块动<br>    QObject::connect(&amp;spinBox, SIGNAL(valueChanged(int)), &amp;slider, SLOT(setValue(int)));<br>    return QApplication::exec();<br>}</p>
<pre><code>
</code></pre>
]]></content>
      <categories>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>C++,Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构与算法-学习笔记(持续更新中...)</title>
    <url>/2022/08/17/AlgorithmNote/</url>
    <content><![CDATA[<h1 id="数据结构与算法"><a href="#数据结构与算法" class="headerlink" title="数据结构与算法"></a>数据结构与算法</h1><h2 id="关于如何使用Clion运行多个main函数？"><a href="#关于如何使用Clion运行多个main函数？" class="headerlink" title="关于如何使用Clion运行多个main函数？"></a>关于如何使用Clion运行多个main函数？</h2><p>用以下代码取代添加可执行文件代码：<code>add_executable(xxx xxx.cpp/h)</code>,对于每一个.cpp文件都会生成对应的.exe文件。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">#递归遍历所有的cpp文件</span><br><span class="line"><span class="built_in">file</span> (GLOB_RECURSE files *.cpp)</span><br><span class="line"></span><br><span class="line">#将所有的cpp文件单独生成可执行文件</span><br><span class="line">foreach (file $&#123;files&#125;)</span><br><span class="line"><span class="built_in">string</span>(REGEX REPLACE <span class="string">&quot;.+/(.+)\\..*&quot;</span> <span class="string">&quot;\\1&quot;</span> exe $&#123;file&#125;)</span><br><span class="line"><span class="built_in">add_executable</span> ($&#123;exe&#125; $&#123;file&#125;)</span><br><span class="line"><span class="built_in">message</span> (\ \ \ \ --\ src/$&#123;exe&#125;.cpp\ will\ be\ compiled\ to\ bin/$&#123;exe&#125;)</span><br><span class="line"><span class="built_in">endforeach</span> ()</span><br></pre></td></tr></table></figure>

<p>注意事项：</p>
<p>1.每次添加新文件后需要重新加载CMake项目。</p>
<p>2.这样修改适合使用Clion用于c++刷题。</p>
<h2 id="一-认识复杂度和简单排序算法"><a href="#一-认识复杂度和简单排序算法" class="headerlink" title="一.认识复杂度和简单排序算法"></a>一.认识复杂度和简单排序算法</h2><h3 id="1-时间复杂度"><a href="#1-时间复杂度" class="headerlink" title="1.时间复杂度"></a>1.时间复杂度</h3><h4 id="1-1常数操作定义"><a href="#1-1常数操作定义" class="headerlink" title="1.1常数操作定义"></a>1.1常数操作定义</h4><p>一个操作如果和样本的数据量没有关系，每次都是固定时间内完成的操作，叫做常数操作。</p>
<h4 id="1-2求解时间复杂度"><a href="#1-2求解时间复杂度" class="headerlink" title="1.2求解时间复杂度"></a>1.2求解时间复杂度</h4><p>在算法流程中找出发生了多少常数操作，进而写出常数操作数量的表达式，取其最高项次数f(n),则时间复杂度为O(f(n))。</p>
<h4 id="1-3评价一个算法流程的好坏"><a href="#1-3评价一个算法流程的好坏" class="headerlink" title="1.3评价一个算法流程的好坏"></a>1.3评价一个算法流程的好坏</h4><p>先看时间复杂度，随后分析不同数据样本下的实际运行时间。</p>
<p>如下代码经多次运行测试，process2大部分情况下要比process1用时短。</p>
<p>原因：</p>
<p>1.加法-基本运算：异或操作。</p>
<p>2.减法-补码加运算：实际上加法也是补码加运算，只是在数据前用0表示正，1表示负。</p>
<p>3.乘法-移位相加。</p>
<p>4.除法-移位相减。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> @author : Song Jiaqi </span></span><br><span class="line"><span class="comment"> @date : 2022-08-10 12:24  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">process1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> N = <span class="number">1000</span>;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            a = <span class="number">2</span> + <span class="number">6</span>;</span><br><span class="line">            a = <span class="number">6</span> * <span class="number">9</span>;</span><br><span class="line">            a = <span class="number">8</span> * <span class="number">4</span>;</span><br><span class="line">            a = <span class="number">90</span> / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">process2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> N = <span class="number">1000</span>;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="comment">//位运算</span></span><br><span class="line">            a = <span class="number">2</span> | <span class="number">6</span>;</span><br><span class="line">            a = <span class="number">6</span> &amp; <span class="number">9</span>;</span><br><span class="line">            a = <span class="number">8</span> &amp; <span class="number">4</span>;</span><br><span class="line">            a = <span class="number">90</span> ^ <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> t1 = chrono::steady_clock::<span class="built_in">now</span>();<span class="comment">//获取开始时间</span></span><br><span class="line">    test::<span class="built_in">process1</span>();</span><br><span class="line">    <span class="keyword">auto</span> t2 = chrono::steady_clock::<span class="built_in">now</span>();<span class="comment">//获取结束时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> t3 = chrono::steady_clock::<span class="built_in">now</span>();<span class="comment">//获取开始时间</span></span><br><span class="line">    test::<span class="built_in">process2</span>();</span><br><span class="line">    <span class="keyword">auto</span> t4 = chrono::steady_clock::<span class="built_in">now</span>();<span class="comment">//获取结束时间</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    double rs = chrono::duration&lt;double&gt;(t2-t1).count();//s为单位</span></span><br><span class="line"><span class="comment">//    double rms = chrono::duration&lt;double,milli&gt;(t2 - t1).count();//ms为单位</span></span><br><span class="line">    <span class="type">double</span> rus1 = chrono::<span class="built_in">duration</span>&lt;<span class="type">double</span>, micro&gt;(t2 - t1).<span class="built_in">count</span>();<span class="comment">//us为单位</span></span><br><span class="line">    <span class="type">double</span> rus2 = chrono::<span class="built_in">duration</span>&lt;<span class="type">double</span>, micro&gt;(t4 - t3).<span class="built_in">count</span>();<span class="comment">//us为单位</span></span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;process1: &quot;</span> &lt;&lt; rus1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;process2: &quot;</span> &lt;&lt; rus2 &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-选择排序和冒泡排序复杂度分析"><a href="#2-选择排序和冒泡排序复杂度分析" class="headerlink" title="2.选择排序和冒泡排序复杂度分析"></a>2.选择排序和冒泡排序复杂度分析</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> @author : Song Jiaqi </span></span><br><span class="line"><span class="comment"> @date : 2022-08-10 14:34  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//选择排序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Code01_selectionSort</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//1.每一次循环都能得出一个最大值或最小值，随后得到次大和次小值，以此类推</span></span><br><span class="line">    <span class="comment">//2.因为前面已经有序，最后一个不需要排序</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">selectionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">NULL</span> || length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一层循环确定循环的趟数(length-1)次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="type">int</span> minIndex = i;</span><br><span class="line">            <span class="comment">//第二层循环确定每一躺的最小值的下标</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; length; j++) &#123;</span><br><span class="line">                minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果minIndex发生改变就与i进行交换，否则自己与自己交换无意义</span></span><br><span class="line">            <span class="keyword">if</span> (minIndex != i) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(arr, i, minIndex);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//方法一</span></span><br><span class="line"><span class="comment">//        int temp = arr[i];</span></span><br><span class="line"><span class="comment">//        arr[i] = arr[j];</span></span><br><span class="line"><span class="comment">//        arr[j] = temp;</span></span><br><span class="line">        <span class="comment">//方法二</span></span><br><span class="line">        arr[i] = arr[i] ^ arr[j];</span><br><span class="line">        arr[j] = arr[i] ^ arr[j];</span><br><span class="line">        arr[i] = arr[i] ^ arr[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//冒泡排序</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Code01_bubbleSort</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//每躺循环都能找出一个最大值，同时循环范围总长度要减一</span></span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arr == <span class="literal">NULL</span> || length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> lastChangeIndex = <span class="number">0</span>;<span class="comment">//记录最后一次改变的下标</span></span><br><span class="line">        <span class="type">int</span> sortBorder = length - <span class="number">1</span>;<span class="comment">//记录无序数组的边界</span></span><br><span class="line">        <span class="comment">//第一层循环确定循环次数(length-1)次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> e = length - <span class="number">1</span>; e &gt; <span class="number">0</span>; e--) &#123;</span><br><span class="line">            <span class="type">bool</span> isSorted = <span class="literal">true</span>;<span class="comment">//定义该变量来判断是否有序，在有序情况下就不进行排序</span></span><br><span class="line">            <span class="comment">//第二层循环每相邻两个数做比较，并把较大数放到右边。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; sortBorder; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                    isSorted = <span class="literal">false</span>;<span class="comment">//有元素交换说明无序</span></span><br><span class="line">                    Code01_selectionSort::<span class="built_in">swap</span>(arr, i, i + <span class="number">1</span>);</span><br><span class="line">                    lastChangeIndex = i + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sortBorder = lastChangeIndex;</span><br><span class="line">            <span class="comment">//一趟下来是否发生位置交换，如果没有交换直接跳出大循环</span></span><br><span class="line">            <span class="keyword">if</span> (isSorted) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//循环遍历数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">show</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == length - <span class="number">1</span>) &#123;</span><br><span class="line">            cout &lt;&lt; arr[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//    int a[] = &#123;1,3,2,6,5,8,10,9,5,2,6&#125;;</span></span><br><span class="line"><span class="comment">//    int a[] = &#123;1, 3, 6, 8, 10, 5, 2, 9&#125;;</span></span><br><span class="line"><span class="comment">//    int a[] = &#123;5, 8, 5, 2, 9&#125;;</span></span><br><span class="line">    <span class="type">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="type">int</span> length = <span class="built_in">sizeof</span>(a) / <span class="built_in">sizeof</span>(a[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">//    Code01_selectionSort::selectionSort(a, length);</span></span><br><span class="line"><span class="comment">//    cout &lt;&lt; &quot;选择排序后：&quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//    show(a, length);</span></span><br><span class="line">    Code01_bubbleSort::<span class="built_in">bubbleSort</span>(a, length);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;冒泡排序后：&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">show</span>(a, length);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="2-1出现的问题"><a href="#2-1出现的问题" class="headerlink" title="2.1出现的问题"></a>2.1出现的问题</h4><p> **a.*<em>warning: ‘sizeof’ on array function parameter ‘arr’ will return size of ‘int</em>‘ [-Wsizeof-array-argument]</p>
<p>警告：数组函数参数“arr”上的“sizeof”将返回“int*”的大小[-Wsizeof-array-argument]</p>
<p>原因：C&#x2F;C++中如果一个函数接受一个数组作为参数，那么数组将会被退化为指针。</p>
<p>解决办法：在main函数中用<code>sizeof(array)/sizeof(array[0])</code>算好length，再将length传入函数中。</p>
<p>**b.**选择排序有误</p>
<p>原因：比较时使用的是arr[i]而不是arr[minIndex]，在minIndex发生多次变化时会出现排序错误，而i是始终不变的。以下面这个</p>
<p>数组为例，当i&#x3D;8,minIndex&#x3D;8，在遇到第一个比8小的5后minIndex会变为5.而i仍然是8，这就导致如果用的是i作为下标进行比较，</p>
<p>随后minIndex还会变为6，导致排序错误。</p>
<p>参考数组：<code>int a[] = &#123;1, 3, 6, 8, 10, 5, 2, 9&#125;;</code></p>
<p>修改前：<code>minIndex = arr[j] &lt; arr[i] ? j : minIndex;</code></p>
<p><img src="img.png"></p>
<p>修改后：<code>minIndex = arr[j] &lt; arr[minIndex] ? j : minIndex;</code></p>
<p><img src="img_1.png"></p>
<h4 id="2-2总结"><a href="#2-2总结" class="headerlink" title="2.2总结"></a>2.2总结</h4><p>**a.**选择排序是不稳定的排序。</p>
<p>在一趟选择，如果一个元素比当前元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中两个5的相对前后顺序就被破坏了。</p>
<p>**b.**冒泡排序是稳定的排序。</p>
<p>如果相邻两个元素相等，是不会交换的；如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的相对前后顺序并没有改变。</p>
<p>**c.**选择排序和冒泡排序区别：</p>
<p>选择排序会在一趟中选择最大或最小值，然后将进行交换将其放到最右或最左边。</p>
<p>冒泡排序会在一趟中对相邻元素进行比较，一趟结束后最大值会到达最右边。</p>
<p>**d.**复杂度分析-时间复杂度O(n^2),额外空间复杂度O(1)—有限个变量。</p>
<p>选择排序：</p>
<p>0-n-1：最小的放第一个位置，比较n-1次</p>
<p>1-n-1：最小的放第二个位置，比较n-2次</p>
<p>……</p>
<p>冒泡排序：</p>
<p>第一趟比较n-1次</p>
<p>第二趟比较n-2次</p>
<p>第三趟比较n-3次</p>
<p>……</p>
<p>均成等差数列：<img src="img_2.png"></p>
<h4 id="2-3异或运算的理解"><a href="#2-3异或运算的理解" class="headerlink" title="2.3异或运算的理解"></a>2.3异或运算的理解</h4><h5 id="2-3-1关于异或"><a href="#2-3-1关于异或" class="headerlink" title="2.3.1关于异或"></a>2.3.1关于异或</h5><p>1.不相同为1，相同为0或无进位相加。<img src="img_3.png"></p>
<p>2.性质：</p>
<p>​	a.0^n&#x3D;n; n^n&#x3D;0;</p>
<p>​	b.满足交换和结合律。 </p>
<p>3.为什么通过异或可以交换a,b的值？</p>
<p><strong>前提：a，b在内存中为独立的内存区域，两者值可以相同，但两种指向的内存区域不能相同。</strong></p>
<p><img src="img_4.png"></p>
<p><strong>内存区域相同的后果：i和j位置不能相等，否则相当于同样的内存区域自己在和自己异或，会变为0。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">    cout&lt;&lt;arr[i]&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;arr[j]&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    arr[i]=arr[i]^arr[j];</span><br><span class="line">    arr[j]=arr[i]^arr[j];</span><br><span class="line">    arr[i]=arr[i]^arr[j];</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;arr[i]&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;arr[j]&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="img_5.png"></p>
<h5 id="2-3-2题目：找到出现奇数次的数"><a href="#2-3-2题目：找到出现奇数次的数" class="headerlink" title="2.3.2题目：找到出现奇数次的数"></a>2.3.2题目：找到出现奇数次的数</h5><p>要求：时间O(n),空间O(1)</p>
<p>情况：</p>
<p>1.一种数出现奇数次，其他数出现偶数次</p>
<p><strong>异或运算与数的顺序无关，与其出现的次数的奇偶性有关，奇为1，偶为0。</strong></p>
<p>2.两种数出现奇数次，其他数出现偶数次</p>
<p><strong>a.这种情况下，从头到尾进行异或运算可以得到a^b，因为a!&#x3D;b，a^b!&#x3D;0。也就是说在某一位上a为1，b为0，或者是</strong></p>
<p><strong>b为1，a为0。</strong></p>
<p><strong>b.原码&amp;补码(~原码+1)&#x3D;一个数最右侧的1(rightOne)，而这个1出现的位置n就是我们要找的位置。</strong></p>
<p><strong>c.遍历数组先从头到尾进行与运算，此次对象为rightOne，而rigthOne除了位置n，其余位置均为0，也就是说其他数相与后结果必为0，</strong></p>
<p><strong>因此根据在n位置相与的结果为0和不为0，对数组中的数进行划分，而a和b就在这两组之一中。假设条件：相与后为0，每符合条件就</strong></p>
<p><strong>进行一次异或，偶数次的数会消掉，最终剩下a&#x2F;b。</strong></p>
<p><strong>d.用a^b即eor,和a&#x2F;b即onlyOne进行异或，就能得到a&#x2F;b。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> @author : Song Jiaqi </span></span><br><span class="line"><span class="comment"> @date : 2022-08-11 11:36  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1个数出现奇数次</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">num1</span><span class="params">(vector&lt;<span class="type">int</span>&gt; <span class="type">const</span> &amp;arr)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> eor = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> cur:arr) &#123;</span><br><span class="line">        eor ^= cur;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;1个数出现奇数次：&quot;</span> &lt;&lt; eor &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2个数出现奇数次</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">num2</span><span class="params">(vector&lt;<span class="type">int</span>&gt; <span class="type">const</span> &amp;arr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从头异或到尾得到eor=a^b</span></span><br><span class="line">    <span class="type">int</span> eor = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> cur:arr) &#123;</span><br><span class="line">        eor ^= cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//原码与补码相与得到一个数最右侧的1。</span></span><br><span class="line">    <span class="type">int</span> rightOne = eor &amp; (~eor + <span class="number">1</span>);<span class="comment">//~取反，取反+1得到补码。</span></span><br><span class="line">    <span class="type">int</span> onlyOne = <span class="number">0</span>;<span class="comment">//eor&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> cur:arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((cur &amp; rightOne) == <span class="number">0</span>) &#123;<span class="comment">//条件为==0或!=0</span></span><br><span class="line">            onlyOne ^= cur;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;2个数出现奇数次：&quot;</span> &lt;&lt; onlyOne &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; (onlyOne ^ eor) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="built_in">num1</span>(arr);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr2 = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="built_in">num2</span>(arr2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-插入排序的讲解和复杂度分析"><a href="#3-插入排序的讲解和复杂度分析" class="headerlink" title="3.插入排序的讲解和复杂度分析"></a>3.插入排序的讲解和复杂度分析</h3><p>时间复杂度O(n^2),额外空间复杂度O(1)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> @author : Song Jiaqi </span></span><br><span class="line"><span class="comment"> @date : 2022-08-17 09:40  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swapIndex</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> i, <span class="type">int</span> j)</span> </span>&#123;</span><br><span class="line">    arr[i] = arr[i] ^ arr[j];</span><br><span class="line">    arr[j] = arr[i] ^ arr[j];</span><br><span class="line">    arr[i] = arr[i] ^ arr[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertionSort</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">NULL</span> || length &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//0-0已经有序，想让0-i有序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="comment">//j指向当前所在数的前一个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; arr[j + <span class="number">1</span>]; j--) &#123;</span><br><span class="line">            <span class="built_in">swapIndex</span>(arr, j, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">showArr</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="type">int</span> l = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">    <span class="built_in">insertionSort</span>(arr, l);</span><br><span class="line">    <span class="built_in">showArr</span>(arr, l);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-1对时间复杂度的补充说明"><a href="#3-1对时间复杂度的补充说明" class="headerlink" title="3.1对时间复杂度的补充说明"></a>3.1对时间复杂度的补充说明</h4><p>a.O();O代表最差时间复杂度，要考虑最坏情况。</p>
<p>b.eg:7654321</p>
<p>0-1 交换1个</p>
<p>0-2 交换2个</p>
<p>0-3 交换3个</p>
<p>……</p>
<p>成等差数列，因此时间复杂度为O(n^2)。</p>
<h3 id="4-二分法的详解与扩展"><a href="#4-二分法的详解与扩展" class="headerlink" title="4.二分法的详解与扩展"></a>4.二分法的详解与扩展</h3><h4 id="4-1在一个有序数组中找某个数是否存在？"><a href="#4-1在一个有序数组中找某个数是否存在？" class="headerlink" title="4.1在一个有序数组中找某个数是否存在？"></a>4.1在一个有序数组中找某个数是否存在？</h4><p>a.如果使用直接遍历，复杂度为O(n)。</p>
<p>b.采用二分法，如果有16个数，考虑最坏情况，可划分为8,4,2,1个，需要4次即log2 16，</p>
<p>复杂度为log2 N(一般将其写为logN)。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> @author : Song Jiaqi</span></span><br><span class="line"><span class="comment"> @date : 2022-08-10 12:24</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find1</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i:arr) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == num) &#123;</span><br><span class="line">            cout &lt;&lt; num &lt;&lt; <span class="string">&quot;存在&quot;</span> &lt;&lt; endl;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; <span class="string">&quot;不存在&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//二分查找</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find2</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="type">bool</span> flag = <span class="literal">true</span>;</span><br><span class="line">    <span class="type">int</span> low = <span class="number">0</span>, high = arr.<span class="built_in">size</span>()<span class="number">-1</span>, mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] == num) &#123;</span><br><span class="line">            cout &lt;&lt; num &lt;&lt; <span class="string">&quot;存在&quot;</span> &lt;&lt; endl;</span><br><span class="line">            flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; num) &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        cout &lt;&lt; num &lt;&lt; <span class="string">&quot;不存在&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="comment">//    find1(arr, 88);</span></span><br><span class="line">    <span class="built_in">find2</span>(arr, <span class="number">11</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-2在一个有序数组中找某个-gt-x3D-某个数最左侧的位置"><a href="#4-2在一个有序数组中找某个-gt-x3D-某个数最左侧的位置" class="headerlink" title="4.2在一个有序数组中找某个&gt;&#x3D;某个数最左侧的位置"></a>4.2在一个有序数组中找某个&gt;&#x3D;某个数最左侧的位置</h4><p>​	仍然可以使用二分查找法，只是相对于4.1来说循环结束条件会不同，4.1是找到数就退出，而4.2中满足的数有很多，需要找到最左侧哪一个，因此需要等待low不断递增或者high不断递减，直到low&gt;high。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*  </span></span><br><span class="line"><span class="comment"> @author : Song Jiaqi </span></span><br><span class="line"><span class="comment"> @date : 2022-08-10 12:24  </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">find</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;arr, <span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> low = <span class="number">0</span>, high = arr.<span class="built_in">size</span>() - <span class="number">1</span>, mid = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> f1 = <span class="number">0</span>;<span class="comment">//记录符合要求的下标</span></span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt;= num) &#123;</span><br><span class="line">            f1 = mid;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;找到&gt;=&quot;</span> &lt;&lt; num &lt;&lt; <span class="string">&quot;的下标为：&quot;</span> &lt;&lt; f1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//    vector&lt;int&gt; arr = &#123;1, 2, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5&#125;;</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">find</span>(arr, <span class="number">3</span>);</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-3局部最小值"><a href="#4-3局部最小值" class="headerlink" title="4.3局部最小值"></a>4.3局部最小值</h4><p><strong>要求：arr，无序，相邻数一定不相等，时间复杂度&lt;O(N)。</strong></p>
<p><strong>局部最小定义：</strong></p>
<p>​	<strong>最左或右侧：0&lt;1，N-1&lt;N-2，0和N-1就是局部最小；</strong></p>
<p>​	<strong>中间：i&lt;i-1&amp;i&lt;i+1，i就是局部最小。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> @author : Song Jiaqi</span></span><br><span class="line"><span class="comment"> @date : 2022-08-10 12:24</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到任意一个局部最小值</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">findMin</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//数组不为空且长度不为0</span></span><br><span class="line">    <span class="keyword">if</span> (arr == <span class="literal">NULL</span> || length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//0&lt;1，最左侧两个数</span></span><br><span class="line">    <span class="keyword">if</span> (length == <span class="number">1</span> || arr[<span class="number">0</span>] &lt; arr[<span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//N-1&lt;N-2，最右侧两个数</span></span><br><span class="line">    <span class="keyword">if</span> (arr[length - <span class="number">1</span>] &lt; arr[length - <span class="number">2</span>]) &#123;</span><br><span class="line">        <span class="keyword">return</span> length - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//0&gt;1&amp;N-1&gt;N-2,中间某个或某些位置必然存在局部最小值</span></span><br><span class="line">    <span class="type">int</span> low = <span class="number">0</span>, high = length - <span class="number">1</span>, m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        m = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[m] &gt; arr[m - <span class="number">1</span>]) &#123;</span><br><span class="line">            high = m - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[m] &gt; arr[m + <span class="number">1</span>]) &#123;</span><br><span class="line">            low = m + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">15</span>, <span class="number">24</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">1</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="type">int</span> l = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">findMin</span>(arr,l);</span><br><span class="line">    cout&lt;&lt;result&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二分查找不一定必须有序，当可以甩掉一边的数时就可以根据情况使用。</p>
<h1 id="二-认识O-NlogN-的排序"><a href="#二-认识O-NlogN-的排序" class="headerlink" title="二.认识O(NlogN)的排序"></a>二.认识O(NlogN)的排序</h1><h3 id="1-刨析递归行为和其时间复杂度的估算"><a href="#1-刨析递归行为和其时间复杂度的估算" class="headerlink" title="1.刨析递归行为和其时间复杂度的估算"></a>1.刨析递归行为和其时间复杂度的估算</h3><h4 id="1-1递归求数组最大值，系统是如何做的？"><a href="#1-1递归求数组最大值，系统是如何做的？" class="headerlink" title="1.1递归求数组最大值，系统是如何做的？"></a>1.1递归求数组最大值，系统是如何做的？</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> @author : Song Jiaqi</span></span><br><span class="line"><span class="comment"> @date : 2022-08-10 12:24</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">process</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//arr[l...r]上只有一个数，直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr[l];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//二进制右移&gt;&gt;除2.左移&lt;&lt;乘2</span></span><br><span class="line">    <span class="type">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//二分递归</span></span><br><span class="line">    <span class="type">int</span> leftMax = <span class="built_in">process</span>(arr, l, mid);</span><br><span class="line">    <span class="type">int</span> rightMax = <span class="built_in">process</span>(arr, mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="comment">//比较求最大值</span></span><br><span class="line">    <span class="keyword">if</span> (leftMax &gt; rightMax) &#123;</span><br><span class="line">        <span class="keyword">return</span> leftMax;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> rightMax;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getMax</span><span class="params">(<span class="type">int</span> arr[], <span class="type">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">process</span>(arr, <span class="number">0</span>, length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">5</span>, <span class="number">66</span>, <span class="number">45</span>, <span class="number">88</span>, <span class="number">100</span>&#125;;</span><br><span class="line">    <span class="type">int</span> length = <span class="built_in">sizeof</span>(arr) / <span class="built_in">sizeof</span>(<span class="type">int</span>);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">getMax</span>(arr, length) &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于此处对中点的求解：</p>
<p>以下三行代码是等价的。</p>
<p><strong>int mid &#x3D; (l+r)&#x2F;2;</strong></p>
<p><strong>int mid &#x3D; l+(r-l)&#x2F;2;</strong></p>
<p><strong>int mid &#x3D; l+((r-l)&gt;&gt;2);</strong></p>
<h4 id="1-2Master公式"><a href="#1-2Master公式" class="headerlink" title="1.2Master公式"></a>1.2Master公式</h4><p><strong>T(N)&#x3D;a*T(N&#x2F;b)+O(N^d)，子递归需要是等规模的。</strong></p>
<p>1.1符合该公式，可以写为T(N)&#x3D;2*T(N&#x2F;2)+O(1)。</p>
<p>结论：</p>
<p>三个系数确定时，时间复杂度就可以确定。</p>
<p><strong>a.log(b,a)&gt;d—&gt;O(N^log(b,a))</strong></p>
<p><strong>b.log(b,a)&#x3D;d—&gt;O(N^d * logN)</strong></p>
<p><strong>c.log(b,a)<d--->O(N^d)</d---></strong></p>
<h3 id="2-归并排序"><a href="#2-归并排序" class="headerlink" title="2.归并排序"></a>2.归并排序</h3>]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>C++,数据结构与算法</tag>
      </tags>
  </entry>
</search>
